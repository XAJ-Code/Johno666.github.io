import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as l,a as n,b as s,e as p,f as t}from"./app-ee3e8713.js";const c="/assets/c8f1d6da46f0af9ea959c046aa03aa8d-e50f9ff1.jpeg",r="/assets/4b4224f1f3f9bfd62fd59b1395bf834a-03a4e0d2.jpeg",d="/assets/21188410030853d68157c477fa4cd832-8fea0be2.jpeg",u="/assets/8407e0a17c4b932a56cefd43fcda4a8b-34135f5b.jpeg",g="/assets/eddf8c695e4979ce360b0b4ac8ea19a5-3c77b578.jpeg",k="/assets/75279cc4b199dcb2bc29b56e522d935f-9db26833.jpeg",f="/assets/535eff2833533fb712a87db1948d85da-8873e550.jpeg",m="/assets/d8615b7819c9bc9d3d842e7d9e122e78-bb4239f1.jpeg",b="/assets/884f3173db770336037a97455b0adae9-cbc87154.jpeg",v="/assets/1e21900874d7086cb7d6651e603dfa4a-da21ee8e.jpeg",h="/assets/f9bc4df70af563d3fcb125cb20111069-fd542605.jpeg",y="/assets/3bdb449955254e4992dc4344a63e37c2-d801a75f.jpeg",_="/assets/8fd33361082bbd2498ace6a3d9f9e406-f3bf068a.jpeg",S="/assets/bb50da3a5b474f8901effe5cc48c6ef2-957d321b.jpeg",w="/assets/81c9d8e4826c152fb74705fa2308a073-95344782.png",j="/assets/61cec7a19ce3d59ca371620c267874a0-824cb500.png",x="/assets/218085bdbd553bafe8d9b97239ab186d-48da3995.jpeg",C="/assets/dcf6400a36bb6611bd50fc33d561a7af-49a4bdaa.png",E="/assets/7f741cfaaf40befa68c13aa38d881864-0cb8c501.png",T="/assets/fe133d3f88ebc4a003b865e7935007e7-92e87bef.png",z="/assets/184b6ff6a19b752abfccf9eb5f41940d-2d85f7e9.png",A="/assets/62d27bef3af4b14928fa085cf64177a7-599478fb.png",M="/assets/542865306c051dd4ae8a315cf2d85f72-7d655f87.png",B="/assets/f966494f9cb4467d785b04246cb58a5c-ba5b5534.png",q="/assets/b931d8f618682bc5df95f769d6d65507-05d949aa.jpeg",L="/assets/73a02a549e96f4375dbda2d395ef385f-0aa37ce3.png",F="/assets/7c4459570de93b4e92edbf8a55663b5a-cdb9e547.jpeg",O="/assets/3ae3d539152c30a5ff83b3ee66ede07e-8c6055c2.jpeg",I="/assets/2caf89ca1184745d94cf55d4a49b1c54-c7117795.gif",P="/assets/c61087d1ec405516c0236588e7d22928-e585a768.gif",H="/assets/112a017494d9a99ccd4d2c0fd708a51e-0130acbf.gif",R="/assets/7aa3e9e182df3b60a7e8ff7474330160-ba0f8895.gif",D="/assets/5c72a9abcbedd30a8a89dd538a639a22-6fa115e3.gif",U="/assets/ab76d1ee2efffd72fdf785d299f5c15a-83a69563.gif",J="/assets/ab867154139534a98fb6a18a22bb874a-704ba4a0.gif",W="/assets/334e890a5b62fad79c4d1a67d2282c85-78493bf8.png",V="/assets/26c32ae301b586eade3c7b3646a9e495-2d606aae.png",N="/assets/0a56cdc9cbbe424f3b1f64b4920d0439-0bfc34d5.png",X="/assets/3f787e0692763d26441da574f5917074-1e88f579.png",K="/assets/0ef7fae49ff24908c01f7ca3b266e5d3-88dc7d4b.png",G="/assets/160e8c7869b530d5541b524b33aa19c6-d7e1ef4a.png",Q="/assets/ba18180e9f65a69ddfde9a81d41a27e7-1205da13.png",Y="/assets/973436c9788cbf68409a239d12da3ca7-701d3a63.png",Z="/assets/43c0b703b8e2ccd8e74eee6a56d90934-b0beabcd.png",$="/assets/86dcea3fbaaf8b2e8321cfe781e50e6f-a63a20f2.jpeg",nn="/assets/d0ced15f64abfff421d65f1cf64e81a0-f73be947.png",sn="/assets/59e8e50f7bb3bd8886f732308b882dad-d7144788.png",an="/assets/94ecb2a835f83997ddcf93a9cd38453f-9351f94a.png",pn="/assets/6cc6bfd60caf2ead664a6c274b313d5a-61faabb8.png",tn="/assets/99f91159e3ccdf2a1bfd6568e91293ad-47a69bbc.png",en="/assets/b4a8d41d5f0e59bd61f06e515453cf30-399a02ce.png",on="/assets/f8b3be08a021ff3e7bec403e560ebf31-8b52934e.png",ln="/assets/90ba01b71021f68c50ae27a54c6a85e6-e68ca978.jpeg",cn="/assets/7fa18a577a88cbd9567f8d3ed3e0b92b-fa9955f8.png",rn="/assets/0ba5c4fae9b6460cc5b89b803b37a55b-04e999b5.png",dn="/assets/baf85cf87efd7eda7f531bbf2674cf48-1a5a110d.png",un="/assets/2888983fbc78a3911aba8586e51679bf-d205f16e.png",gn="/assets/2098c3b80ed60607a975d30869c93911-45dc73fe.png",kn="/assets/087df4755151630f943257941c8d30fc-f80e8a88.png",fn="/assets/f564a348fe5e53f8ecb71e96f9f718d0-b92e43e7.png",mn="/assets/9b2d9e3009de426f085306ad328bbca5-b0f43669.png",bn="/assets/edd49a0f28fa3d7485e856fb4c4b56b3-ae841643.jpeg",vn="/assets/e56e5e58eeb29194a58f512fed831384-7e01286d.png",hn="/assets/00fccdc0bf0bb394e9294db7c89d35bc-96b2e27b.gif",yn="/assets/ed2889b5555f21b533e1139d12db965e-93ef751c.gif",_n="/assets/981b7cbaf3681425f327c56bce74624c-76287243.jpeg",Sn="/assets/f1791cb6a59b594d94f918b9906ada6a-7cde7f95.jpeg",wn="/assets/cae1731b0fb64b589fd8dc762a30ee30-bf0471fd.gif",jn="/assets/2545d4e64e149021dab552b955c663f3-a9c27fc0.jpeg",xn="/assets/5f786dd30dfe4da1cc14a2f93a763834-1a07c134.jpeg",Cn="/assets/0daf0c8c511f10d7fa8d33bc8e1d1db9-eb44f713.jpeg",En="/assets/45bf05cc88eaa23b8300f965af50cb59-447386a6.jpeg",Tn="/assets/95fe75ee5d5da064f56cbba003e00d2e-eb219c34.gif",zn="/assets/090075b08d64c999872fdca3bc7df41e-218e14ca.jpeg",An={},Mn=t('<h1 id="java-进阶" tabindex="-1"><a class="header-anchor" href="#java-进阶" aria-hidden="true">#</a> Java 进阶</h1><p>2019 年 7 月 19 日 21:55</p><p>学习方法</p><p>课上:<br> 认真听讲<br> 困了站起来听<br> 适当的做笔记</p><p>课下:<br> 总结<br> 读代码, 看明白这段代码的作用, 为什么这样写, 分析输出结果是怎么产生的<br> 写代码, 模仿, 尝试</p><p>切忌:<br> 一直看视频</p><h1 id="第一章-面向对象" tabindex="-1"><a class="header-anchor" href="#第一章-面向对象" aria-hidden="true">#</a> 第一章 面向对象</h1><p><strong>1.1</strong></p><p><strong>包</strong></p><p>在 Java 中, 使用包来管理类. 就像在资源管理器中使用文件夹管理文件一样.</p><p>在同一个包中, 类名不能重名, 在不同包中类名可以相同</p><p>我们这一阶段涉及的包:</p><p>java.lang                   Java 语言的基础包, 系统会自动导入</p><p>java.util                   工具类</p>',14),Bn={href:"http://java.io",target:"_blank",rel:"noopener noreferrer"},qn=n("p",null,"java.text                   文本处理相关的类",-1),Ln={href:"http://java.net",target:"_blank",rel:"noopener noreferrer"},Fn=t("<p>java.math                   数学相关的类</p><p><strong>1.1.1</strong></p><p><strong>包的定义</strong></p><table><thead><tr><th>package com.bjpowernode.chapter01.packages.p1;<br>/<em><br>1) 使用 package 关键字定义包, package 定义包的语句必须作为源文件的第一条语句<br>2) 包名的命名规则:<br>公司域名的倒序.项目名.模块名.子模块名<br>包名一般情况下所有字母都小写<br>3) 编译<br>javac -d .   Test01.java<br>javac 的-d 参数可以指定生成字节码文件的位置(目录)<br>小点.代表当前目录<br>编译后,系统会在当前目录生成与包名对应的文件夹,把字节码文件存储到该文件夹中<br>4) 运行<br>&gt;java com.bjpowernode.chapter01.packages.p1.Test01<br>java 命令后面跟完整类名<br>5) 包名.类名就是完整类名,即<br>com.bjpowernode.chapter01.packages.p1.Test01 是一个完整类名<br>Test01 称为简易类名<br></em>/<br>class Test01 {<br>public static void main(String[] args)     {<br>System.out.println(&quot;Hello World!&quot;);<br>}<br>}</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p><strong>1.1.2</strong></p><p><strong>使用其他包的类</strong></p><p>package com.bjpowernode.chapter01.packages.p2;</p><p>/*</p><p>需求:</p><p>在当前包中, 使用 p3 包中的 MyUtil 类,调用它的静态方法</p><p>前提:</p><p>被使用的类必须定义为 public 修饰的公 共类</p><p>使用方式:</p><p>1)直接使用完整类名</p><p>2)先通过 import 导入被使用的类,再通过简易类名访问</p><p>*/</p><p>import com.bjpowernode.chapter01.packages.p3.MyUtil;       //是把被使用的类导入到当前文件中</p><p>class Test02{</p><p>public static void main(String[] args)     {</p><p>System.out.println(&quot;在 p2 包中调用 p3 包中的 MyUtil 类的静态方法&quot;);</p><p>//1)直接通过完整类名调用</p>",21),On={href:"http://com.bjpowernode.chapter01.packages.p3.MyUtil.sm",target:"_blank",rel:"noopener noreferrer"},In=n("p",null,"//2)先把其他包中的类导入,再使用简易类名调用",-1),Pn={href:"http://MyUtil.sm",target:"_blank",rel:"noopener noreferrer"},Hn=n("p",null,"}",-1),Rn=n("p",null,"}",-1),Dn=n("br",null,null,-1),Un=n("em",null,[n("br"),s("需求:"),n("br"),s("在当前包中, 使用 p3 包中的 MyUtil 类,调用它的静态方法"),n("br"),s("前提:"),n("br"),s("被使用的类必须定义为 public 修饰的公 共类"),n("br"),s("使用方式:"),n("br"),s("1)直接使用完整类名"),n("br"),s("2)先通过 import 导入被使用的类,再通过简易类名访问"),n("br")],-1),Jn=n("br",null,null,-1),Wn=n("br",null,null,-1),Vn=n("br",null,null,-1),Nn=n("br",null,null,-1),Xn=n("br",null,null,-1),Kn=n("br",null,null,-1),Gn={href:"http://com.bjpowernode.chapter01.packages.p3.MyUtil.sm",target:"_blank",rel:"noopener noreferrer"},Qn=n("br",null,null,-1),Yn=n("br",null,null,-1),Zn={href:"http://MyUtil.sm",target:"_blank",rel:"noopener noreferrer"},$n=n("br",null,null,-1),ns=n("br",null,null,-1),ss=t('<p>|package com.bjpowernode.chapter01.packages.p3;<br>public class MyUtil {<br>public static void sm()   {<br>System.out.println(&quot;我是 p3 包中 MyUtil 类的静态方法 sm&quot;);<br>}<br>}|</p><p><strong>1.2 Eclipse</strong></p><p><strong>1.2.1</strong></p><p><strong>准备工作</strong></p><p>1)下载 Eclipse</p><p>Eclipse neon           JDK8</p><p>Eclipse Oxygen       JDK9</p><p>Eclipse Photon       JDK10</p><ol start="2"><li>安装</li></ol><p>不需要安装, 只要解压缩即可</p><ol start="3"><li>检查 JDK 版本是否 JDK8</li></ol><p>java -version</p><ol start="4"><li>查看是否安装了公共的 JRE</li></ol><p>在安装目录 C: \\Program Files\\Java 中查看,除了 jdk 目录外,是否还有 jre 目录</p><p>如果有 jre 目录,表示安装了公共的 JRE, 建议重新安装 JDK, 不安装公共的 JRE</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="5"><li>查看是否配置了 classpath 环境变量</li></ol><p>set classpath</p><p>查看是否配置 classpath,如果已经配置, 建议你删除该环境变量.</p><p><strong>1.2.2 Eclipse</strong></p><p><strong>的基本配置</strong></p><ol><li>设置工作区目录</li></ol><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>切换 JavaSE 透视图</li></ol><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>1.2.3</strong></p><p><strong>项目创建与运行</strong></p><ol><li>创建项目</li></ol><p>在 Eclipse 环境中, 需要把类放在项目中才能运行</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>在项目中添加类</li></ol><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>运行程序</li></ol><p>runà run</p><p>单击常用工具栏的运行按钮</p><p>在编辑区中,右键, run as -&gt; java application</p><p>Ctrl + F11           运行程序的快捷键</p><p><strong>1.2.4 Eclipse</strong></p><p><strong>首选项常用设置</strong></p><ol><li>设置字号</li></ol><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>设置智能提示</li></ol><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>设置工作区 编码格式</li></ol><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>1.2.5</strong></p><p><strong>在项目中添加已有的类</strong></p><ol><li><p>直接把.java 源文件复制到 src 目录中对应的包下</p></li><li><p>把源码复制到 Src 目录中,系统会创建对应的包与源文件</p></li></ol><p>在项目中添加已有的源文件,可能出现乱码, 出现乱码的原因是, 源文件保存时使用的编码格式与当前工作区使用的编码格式不兼容</p><p>ANSI 编码不是一种具体的文件编码, 在中文 Windows 操作系统中 ANSI 是默认的中文编码 GBK, 如果是日文操作系统,ANSI 编码就是日文的一种默认编码.</p><p>打开文件, 另存为, 选择文件的编码格式与当前工作区的编码格式一致(UTF-8).重新复制粘贴 到当前项目中</p><p><strong>1.2.6</strong></p><p><strong>在工作区中导入已有的项目</strong></p><p>选择 fileà import</p><p>在包浏览器中右键, import</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可能会出现命名冲突</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果工作区中已存在导入的项目名称 ,可以修改工作区中的项目名称</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意:</p><p>导入的项目,可能会出现乱码, 建议修改工作区的文件编码去适配项目的编码</p><p><strong>1.3</strong></p><p><strong>访问权限</strong></p><p><strong>1.3.1</strong></p><p><strong>类的访问权限</strong></p><p>类的访问权限: 公共类 和非公共类</p><p>使用 public 修饰的类就是公共类,</p><p>公共类的应用场景:</p><p>如果这个类想在其他包中使用,需要定义为公共类; 如果这个类没有使用 public 修饰,这个类只能在当前包中使用</p><p><strong>1.3.2</strong></p><p><strong>类成员的访问权限</strong></p><table><thead><tr><th>访问权限</th><th>当前类</th><th>当前包</th><th>不在当前包中的派生类(子类)</th><th>其他包</th></tr></thead><tbody><tr><td>私有的 private</td><td>可以</td><td>不</td><td>不</td><td>不</td></tr><tr><td>默认的没有权限修饰符</td><td>可以</td><td>可以</td><td>不</td><td>不</td></tr><tr><td>受保护的 protected</td><td>可以</td><td>可以</td><td>可以</td><td>不</td></tr><tr><td>公共的 public</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>访问权限遵循权限最小化原则</p><p>想在任意位置都可以访问就定义为 public 公共的</p><p>在当前类和派生类中可以直接访问就定义为 protected 受保护的</p><p>代码: com.bjpowernode.chapter01.privilage.p3/ com.bjpowernode.chapter01.privilage.p4</p><p><strong>1.4 Object</strong></p><p>Object 类是 Java 中所有类的根父类, Java 中的类要么直接继承 Object, 要么间接继承 Object 类</p><p>Java 中类的继承是可传递的, Object 类中定义的方法,所有的类都能继承到</p><ol><li>toString()</li></ol><p>作用是把对象转换为字符串</p><p>应用场景: System.out.println( obj ) 打印 obj 对象时, 会调用对象的 toString()方法</p><p>当打印对象时,想显示对象的各个字段值, 需要重写 toString()</p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>equals()</li></ol><p>使用关系 运算符 == 判断两个变量是否相等, 如果两个变量相等,说明这两个变量引用堆中的同一个对象</p><p>如果想要判断堆中两个对象的内容(即各个成员变量的值)是否一样 ,需要重写 equals()方法, 根据哈希约定, 如果两个对象的 equals()相等, 那么这两个对象的 hashCode()也应该相等,即在重写 equals()方法的同时,也要重写 hashCode()</p><ol><li>定义实体类 <ol><li>一般把所有字段都私有化，提供公共的 getter（）/setter（）方法对字段进行访问</li><li>一般只提供无参构造</li><li>一般需要重写 tostring（），equals（）/hashCode（）</li></ol></li></ol><figure><img src="'+j+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>常用快捷键</li></ol><table><thead><tr><th>Alt + /</th><th>智能提示</th></tr></thead><tbody><tr><td>Ctrl + 1</td><td>快速修复</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl + W</td><td>关闭当前窗口</td></tr><tr><td>Ctrl + Shift + W</td><td>关闭所有窗口</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl + S</td><td>保存</td></tr><tr><td>Ctrl + Shift + S</td><td>保存所有</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl + /</td><td>单行/取消注释</td></tr><tr><td>Ctrl + Shift + /</td><td>块注释</td></tr><tr><td>Ctrl + Shift + \\</td><td>取消块注释</td></tr><tr><td>Ctrl + Shift + F</td><td>代码格式化(自动对齐)</td></tr><tr><td>Ctrl + Shift + O</td><td>自动导入所有需要的类</td></tr><tr><td></td><td></td></tr><tr><td>Shift + Enter</td><td>在当前行的下面产生空行</td></tr><tr><td>Ctrl + Alt + 向下箭头</td><td>复制一行</td></tr><tr><td>Alt + 向下/向上箭头</td><td>移动一行</td></tr><tr><td>Ctrl + D</td><td>删除一行</td></tr><tr><td></td><td></td></tr><tr><td>Alt + Shift + R</td><td>重命名</td></tr><tr><td>Alt + Shift + M</td><td>把一段代码抽象为一个方法</td></tr><tr><td>Alt + Shift + L</td><td>把一个表达式赋值给一个局部变量</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl + Shift + T</td><td>打开 类型</td></tr><tr><td>Ctrl + O</td><td>显示类成员</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl + F11</td><td>运行程序</td></tr><tr><td>F11</td><td>调试程序</td></tr><tr><td>Ctrl + Shift + B</td><td>添加/取消断点</td></tr></tbody></table><p>小结:</p><p>1)理解包的作用, 掌握包的定义, 掌握如何使用其他包中的类</p><p>2)Eclipse 的使用(重点), 学会创建项目, 在项目中添加类, 运行程序, 在项目中添加已有的类, 在工作区中添加已有的项目, 解决可能出现的乱码问题, Eclipse 的基本设置(编码,字号,智能提示…)</p><p>3)记住类的两个访问权限, 理解类成员的四个访问权限及他们的使用范围</p><ol start="4"><li>Object 类的特点, 了解 clone() / finalize() / getClass() / notify() / wait()</li></ol><p>理解 toString()的作用 , 应用场景 , 如何用</p><p>理解 equals()作用, 如何用</p><p>了解根据哈希约定, 两个对象 equals()相等,这两个对象的 hashCode 也应该相等, 即需要同时重写 equals()/hashCode()</p><p>5)认识程序调试</p><p>程序调试是为查看程序的运行过程, 查看在程序运行过程中各个变量的取值</p><p>如何调试?</p><p>练习:</p><ol><li>定义一个宠物类, 宠物会卖萌; 定义小狗/小猫/小猪等类,继承宠物类, 重写卖萌方法; 定义主人类, 主人可以给宠物喂食, 喂食时宠物就卖萌</li><li>定义一个计算机类, 包括若干的字段, 重写 toString()/ equals()…., 定义测试类, 打印计算机对象, 判断两个计算机对象是否相同</li><li>编程程序, 从键盘上输入年月日, 打印该日期对应这一年的第几天. 如</li></ol><p>输入 :</p><p>2018   1   5</p><p>输出:</p><p>2018-1-5 是 2018 年的第 5 天</p><p>输入 :</p><p>2018 2   5</p><p>输出:</p><p>2018-2-5 是 2018 年的第 36 天</p><p>输入 :</p><p>2018   3   5</p><p>输出:</p><p>2018-3-5 是 2018 年的第 64 天</p><p><strong>1.5 final</strong></p><p><strong>关键字</strong></p><p>final 是一个关键字, 可以修饰类, 修饰字段,修饰方法,修饰局部变量,修饰形参</p><p>final 修饰类表示最终类, 不能被继承</p><p>final 修饰字段,必须显示初始化, 不能再修改, 一般 final 与 static 同时修饰某个字段,所有字母都大写,称为 final 常量</p><p>final 修饰方法,不能被子类覆盖(重写), 能被子类继承</p><p>final 修饰局部变量, 一旦初始化就不能再修改, 注意 final 修饰引用类型变量, 是指这个引用类型变量不能再指向其他对象,可以修饰它的字段</p><p>final 修饰方法形参, 在方法体中不能修改 final 形参的值</p><p><strong>1.6</strong></p><p><strong>抽象类</strong></p><ol><li>对一组对象进行更高层级抽象时, 形成现抽象的类, 就可以定义为抽象类</li></ol><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2)含有抽象方法的类必须定义为抽象类</p><ol><li>为什么定义抽象类?</li></ol><p>对事物进行进一步抽象可以形成抽象类, 如动物类,交通工具类,食品类</p><p>含有抽象方法的类必须定义为抽象类</p><ol><li>如何定义抽象类</li></ol><p>使用 abstract 修饰的类</p><ol><li>为什么定义抽象方法?</li></ol><p>当一个类的某个操作无法具体实现时,这个操作可以定义为抽象方法</p><p>使用 abstract 修饰方法, 只有方法的声明, 没有方法体</p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>如何使用抽象类</li></ol><p>抽象类一般作为其他类的父类存在</p><p>子类继承了抽象类, 子类需要重写抽象类中所有的抽象方法, 如果子类没有重写所有的抽象方法,子类也需要定义为抽象类</p><p>注意:</p><p>抽象类中不一定含有抽象方法</p><ol><li>抽象类也是一种引用数据类型，定义变量</li><li>Java 数据类型包括基本类型与引用类型，其中引用类型包括：类，接口，数组，枚举</li><li>抽象类不能实例化对象, 需要赋值子类对象（多态）</li><li>抽象类的引用可以赋值匿名内部类对象</li><li>报错 Cannot instantiate the type Animal 不能实例化</li><li>抽象类可以赋值匿名内部类对象</li></ol><p>Anima l = new Animal（{</p><p>}；</p><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>abstract 与 final 可以共存? 不能</li></ol><p><strong>1.7</strong></p><p><strong>接口</strong></p><p><strong>1.7.1</strong></p><p><strong>定义与实现</strong></p><p>电脑上的接口有哪些?</p><p>USB 接口, 耳机接口, 电源接口, VGA 接口, 网线接口, HDMI 高清接口..</p><p>不同型号的电脑上的接口也有不同</p><p>所有的 USB 插头的设备不是同一家厂商生产的,</p><p>电脑通过这些接口连接更多的外设,扩展了电脑的功能</p><p>Java 中的接口就是功能的封装, 用来扩展类的功能</p><p>接口也可以理解为一组操作规范,或者是一个协议</p><p>如何定义接口?</p><p>[修饰符] interface 接口名 {</p><p>功能,用方法表示, 接口中的方法默认使用 public abstract 修饰</p><p>}</p><p>如何使用接口?</p><p>class 类 implements 接口 {</p><p>重写接口中抽象方法</p><p>}</p><p><strong>1.7.2</strong></p><p><strong>接口说明</strong></p><ol><li>接口内容:接口中方法默认使用 public abstract 修饰, 接口中还可以定义 public static final 常量 , public static 方法, public default 方法</li></ol><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2)类实现了接口,需要重写接口的抽象方法, 如果没有重写接口中所有的抽象方法,实现类需要定义为抽象类</p><p>3)接口是一种引用数据类型, 可以定义变量, 但是接口不能实例化对象, 接口引用需要赋值实现类对象, 或者接口的匿名内部类对象</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>4)接口多态, 接口引用调用接口中抽象方法,实际上执行的是实现类对象的方法. 接口存在就是为实现多态的.</p><p>5)一个类可以同时实现多个接口, 需要重写所有接口的所有抽象方法</p><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>6)接口也支持继承,并且接口支持多继承</p><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>1.7.3</strong></p><p><strong>接口与抽象类的异同点</strong></p><p>相同点:</p><p>1)都可以定义抽象方法</p><p>2)都不能实例化对象</p><p>3)定义的抽象方法都需要被重写</p><p>4)都可以定义 public static 方法, public static final 常量</p><p>不同点:</p><p>1)意义不同</p><p>抽象类是对事物更高层级的抽象</p><p>接口是对功能的封装</p><p>2)定义方式不同</p><p>抽象类用 abstract class 定义</p><p>接口用 interface 定义</p><p>3)内容不同</p><p>抽象类中除了抽象方法外,还可以定义构造方法等普通类中定义的所有成员</p><p>接口除了抽象方法等这四个内容外, 不能定义构造方法等内容</p><p>4)使用方式不同</p><p>抽象类需要被子类 extends 继承</p><p>接口需要被实现类 implements 实现</p><p>5)类只支持单继承, 接口支持多继承</p><p>6)应用场景不同</p><p>一般情况下, 对类进行功能的扩展,优先选择接口</p><p>除了扩展功能外, 还需要保存不同的数据,只能选择抽象类; 抽象类的抽象方法需要子类重写, 抽象类还可以约束所有的子类都具有相同的功能.</p><p><strong>1.7.4</strong></p><p><strong>接口的应用</strong></p><p>1)使用接口用来封装功能(操作)</p><p>如在 Flyable 接口中封装了 fly()飞行功能, 在 Swimmable 接口中封装 swim()游泳功能</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2)接口可以定义一组操作规范</p><p>如开发某个项目时, 在相似模块中有一些操作是相同的, 可以把这一组相同的操作封装在一个接口中,就相当于通过接口定义了一个操作规范</p><p><strong>1.7.5</strong></p><p><strong>提倡面向接口的编程</strong></p><p>1)接口使用比较灵活,一个类在继承父类的同时,可以实现多个接口</p><p>描述打工的学生</p><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>练习:</p><p>描述带橡皮的铅笔</p><ol start="2"><li><p>接口比较容易扩展, 接口引用可以赋值各种实现类对象,经常把接口引用作为方法形参,在调用方法时,可以传递各种实现类对象</p></li><li><p>接口可以使项目分层</p></li></ol><p>分析项目不分层的弊端</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+O+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>小结:</p><ol><li>记住 final 关键修饰类,字段,方法,局部变量,形参分别有什么特点</li><li>理解为什么定义抽象类? 对事物进行更高层级的抽象就会形成抽象类;含有抽象方法的类必须定义为抽象类</li><li>如何定义抽象类?   使用 abstract 修饰类</li><li>为什么定义抽象方法? 如何定义抽象方法?</li><li>记住抽象类特点</li><li>理解接口是什么 ? 功能的封装, 也可以理解为一组操作规范</li><li>掌握如何定义接口, 如何使用接口</li><li>记住接口的特点</li><li>理解接口与抽象类的异同点</li><li>记住接口的应用,记住为什么提倡面向接口编程</li></ol><p>练习 1 :</p><p>定义平面图形类, 有求面积,求周长的操作, 这两个操作在不同图形中有不同实现</p><p>定义矩形类继承平面图形类</p><p>定义圆形类继承平面图形类</p><p>定义测试类, 定义一个方法, 可以打印任意平面图形的面积与周长, 在 main 方法中测试打印矩形与圆形的面积与周长</p><p>练习 2:</p><p>打印机可以打印内容, 不同种类的打印机的打印方式不同</p><p>人可以使用针式打印机/喷墨打印机/激光打印机来打印内容</p><p>练习 3:</p><p>定义一个 USB 接口, 封装 connect()连接功能,和 disconnect()断开连接功能</p><p>再定义鼠标类/键盘类实现 USB 接口</p><p>再定义 Computer 计算机类, 有连接 USB 设置的操作</p><p>再定义测试类</p><p>练习 4:</p><p>定义一打打折的接口, 封装一个折扣操作, 可以根据原价计算 折扣之后 的价格</p><p>定义一个不打折的类实现打折接口,</p><p>定义一个八折实现类实现打折接口</p><p>再定义按比例返现的 类实现打折接口</p><p>定义一个商品类, 该类有商品名称,原价,打折方式等几个字段,定义一个方法,打印商品折扣之后的价格</p><p>练习 5 :</p><p>定义一个 Movable 移动接口, 封装一个 move()移动操作</p><p>定义 NoLegs 类实现 Movable 接口, 重写抽象方法,没有腿的移动方式</p><p>定义 TwoLegs 类实现 Movable 接口, 使用两条腿的移动方式</p><p>定义 TwoLegs 类实现 Movable 接口, 使用四条腿的移动方式</p><p>定义一个动物类, 该类有一个移动方式属性, 有移动的操作(使用该动物的移动方式进行移动)</p><p>定义小狗类继承动物类, 定义蛇类继承动物类, 定义人类继承动物类</p><p>测试,小狗使用四条腿走路, 人使用两条腿走路, 蛇没有腿也能移动</p><p><strong>1.8</strong></p><p><strong>类与类之间的关系</strong></p><p><strong>视频</strong></p><p><strong>186</strong></p><p><strong>集</strong></p><p><strong>_</strong></p><p><strong>类与类之间的关系</strong></p><p>1)泛化(继承)</p><p>一个类继承另外一个类, 一个接口继承其他接口</p><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>实现</li></ol><p>一个类实现接口</p><figure><img src="'+P+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>3)依赖</p><p>一个 A 类的方法返回值类型,方法参数类型或者是局部变量类型是另外一个 B 类,称 A 类依赖 B 类</p><figure><img src="'+H+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>4)关联</p><p>如果 A 类使用 B 类定义了成员变量,称 A 类关联 B 类</p><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>5)聚合</p><p>聚合是关联的一种, 如果一个类 A 是由若干的 B 类组成的并且不能决定 B 的生命周期,称 A 类为聚合类</p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>6)组合</p><p>组合是关联的一种, 如果一个类 A 是由若干的 B 类组成,并且可以决定 B 的生命周期,称 A 类为组合类</p><figure><img src="'+U+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>is a, 子类 is a 父类, 是继承关系, 也只有两个类符合 is a 关系时才能使用继承</p><p>like a, 类 like a 接口, 是实现关系,</p><p>has a, A 类 has a B, 关联关系</p><p><a href="onenote:%E7%9F%A5%E8%AF%86%E7%82%B9%E5%89%AA%E8%BE%91%E5%AD%98%E6%94%BE.one#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E5%85%B3%E8%81%94%EF%BC%8C%E7%BB%84%E5%90%88%EF%BC%8C%E8%81%9A%E5%90%88%EF%BC%8C%E4%BE%9D%E8%B5%96%EF%BC%89%20-%20wdjxxl%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%E5%8D%9A%E5%AE%A2&amp;section-id=%7BE9AD3268-AF34-4CA1-AF2C-63D682135ECF%7D&amp;page-id=%7BE086EF15-32EE-42AA-AC29-DD41F225E946%7D&amp;end&amp;base-path=https://d.docs.live.net/ec6f295088dd84ec/%E6%96%87%E6%A1%A3/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">类与类的关系（关联，组合，聚合，依赖） - wdjxxl 的博客 - CSDN 博客</a></p><h1 id="第二章-异常" tabindex="-1"><a class="header-anchor" href="#第二章-异常" aria-hidden="true">#</a> 第二章 异常</h1><p><strong>2.1</strong></p><p><strong>异常</strong></p><p><strong>概述</strong></p><p>异常就是程序运行过程中出现了不正常现象导致程序中断</p><p>在 Java 中, 把各种异常现象进行了抽象形成了异常类</p><figure><img src="'+J+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>2-2</strong></p><p><strong>异常处理</strong></p><p>运行时异常不需要预处理,通过规范的代码可以避免</p><p>受检异常必须预处理, 否则编译报错, 有两种预处理方式 :</p><ol><li>捕获处理</li><li>抛出处理</li></ol><figure><img src="'+W+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>2.2.1</strong></p><p><strong>异常捕获处理</strong></p><figure><img src="'+V+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>try{</p><p>对可能产生异常的代码进行检视</p><p>如果 try 代码块的某条语句产生了异常, 就立即跳转到 catch 子句执行,try 代码块后面的代码不再执行</p><p>try 代码块可能会有多个受检异常需要预处理, 可以通过多个 catch 子句分别捕获</p><p>}catch( 异常类型 1   e1){</p><p>捕获异常类型 1 的异常,进行处理</p><p>在开发阶段, 一般的处理方式要么获得异常信息,要么打印异常栈跟踪信息</p><p>e1.printStackTrace();</p><p>在部署后, 如果有异常,一般把异常信息打印到日志文件中</p><p>} catch( 异常类型 2   e1){</p><p>捕获异常类型 2 的异常,进行处理</p><p>如果捕获的异常类型有继承关系, 应该先捕获子异常再捕获父异常; 如果没有继承关系, catch 子句没有先后顺序</p><p>}finally{</p><p>不管是否产生了异常,finally 子句总是会执行</p><p>一般情况下,会在 finally 子句中释放系统资源</p><p>}</p><p>如:</p><p>try{</p><p>同学抽烟</p><p>扔烟头,引起纸团着火</p><p>打火机爆炸引起被包着火</p><p>宿舍着火</p><p>}catch(抽烟引起纸团着火   e ){</p><p>用脚踩</p><p>}catch( 被包着火 e2){</p><p>使用灭火器</p><p>}catch( 宿舍着火 ){</p><p>119</p><p>}</p><p>final/finalize/finally 的区别</p><figure><img src="'+X+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+K+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>2.2.2</strong></p><p><strong>throws</strong></p><p><strong>抛出处理</strong></p><p>在定义方法时, 如果方法体中有 受检异常需要预处理, 可以捕获处理,也可以抛出处理.</p><p>谁调用这个方法,谁负责处理该 异常,</p><p>在定义方法时,把异常抛出就是为了提醒方法的使用者,有异常需要预处理</p><figure><img src="'+G+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+Q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在处理异常时, 是选择捕获处理还是抛出处理??</p><p>1)一般情况下, 在调用其他方法时, 如果被调用的方法有受检异常需要预处理, 选择捕获处理</p><p>2)在定义方法时, 如果方法体中有受检异常需要预处理,可以选择捕获 ,也可以选择抛出处理; 如果方法体中通过 throw 语句抛出了一个异常对象,所在的方法应该使用 throws 声明该异常</p><p><strong>2.3</strong></p><p><strong>方法覆盖中的异常处理</strong></p><p>方法覆盖(重写)规则:</p><ol><li>方法签名必须相同, 方法名与参数列表就是方法签名</li><li>方法的返回值类型可以相同 , 子类方法的返回值类型可以是父类方法返回值类型的子类型</li><li>子类方法的访问权限可以更宽泛(更大), <ol><li>如果父类方法使用 public 修饰,子类方法只能是 public 修饰</li><li>如果父类方法使用 protected 修饰,子类方法可以是 protected/public 修饰</li></ol></li><li>子类方法的异常要比父类方法的异常更小, <ol><li>如果父类方法没有抛出异常,子类重写后也不能抛出异常</li><li>如果父类方法抛出了异常,子类方法可以抛出相同的异常,也可以抛出父类异常的子异常,也可以不抛出异常</li></ol></li><li><img src="'+Y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ol><p><strong>2.4</strong></p><p><strong>异常在开发中应用</strong></p><p>自定义异常</p><p>1)定义一个类继承 Exception</p><p>2)在自定义异常类中提供两个构造方法</p><p>3)在需要的位置通过 throw 抛出异常对象</p><p>4)throw 所在的方法通过 throws 声明该异常</p><p>5)调用方法时,需要对受检异常预处理</p><figure><img src="'+Z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>throw 和 throws 的区别:</p><p>1、throws 出现在方法函数头；而 throw 出现在函数体。</p><p>2、throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常。</p><p>3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p><h1 id="第三章-数组" tabindex="-1"><a class="header-anchor" href="#第三章-数组" aria-hidden="true">#</a> 第三章 数组</h1><p><strong>3.1</strong></p><p><strong>一维数组的定义与访问</strong></p><p>保存一个数据可以定义一个变量, 如果保存 100 个数据呢??可以使用数组</p><p>数组用来保存同一类型若干数据的容器</p><p>如何定义数组?</p><p>数据类型 [] 数组名 = new 数据类型[数组的长度];</p><p>说明:</p><ol><li>数据类型就是数组中存储元素的数据类型</li><li>方括弧就是定义的是数组</li><li>数组名其实就是一个变量名, 保存数组的引用(数组的起始地址)</li><li>new 运算符会在堆中分配一块连续的存储空间, 把这块连续存储空间的引用(起始地址)保存到数组名中</li><li>数组本质上就是堆中一块连续的存储空间</li></ol><p>如:</p><p>int [] data = new int[5];</p><p>定义一个数组,这个数组可以存储 5 个 int 类型的数据,数组名是 data</p><p>如何访问数组?</p><p>通过索引值访问数组的元素</p><p>定义一数组之后 ,系统为每个元素指定一个索引值, 索引值是从 0 开始的,即数组 data 的 5 个元素分别是:</p><p>data[0] , data[1], data[2] , data[3] , data[4]</p><p>为什么通过索引值可以访问数组的元素??</p><figure><img src="'+$+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+nn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+sn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.2</strong></p><p><strong>数组的遍历</strong></p><figure><img src="'+an+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>静态初始化：</p><figure><img src="'+pn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>也可以写成 int [ ] data2 = {34,65,123,78,66} ;</p><p>静态初始化时，不能在 [ ] 中写数字，会编译错误</p><figure><img src="'+tn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>foreach 循环</p><figure><img src="'+en+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>int [] data = new int[]{45,675,78,23};</p><p>for( int i = 0 ; i &lt; data.length; i++){</p><p>System.out.print( data[i] + “\\t”);</p><p>}</p><p>System.out.println();</p><p>也可以使用 foreach 循环</p><p>for( int xx : data ){</p><p>System.out.print( xx + “\\t”);</p><p>}</p><figure><img src="'+on+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>小结:</p><ol><li>记住类与类之间的几种关系, 尽量能画出关系图</li><li>知道异常是什么</li></ol><p>掌握异常的类结构, 能够画出异常类的结构图</p><p>掌握异常处理的两种方式, 知道如何选择异常的处理方式?</p><p>理解方法覆盖的规则</p><p>掌握自定义异常的方法</p><p>3)数组的作用是什么</p><p>掌握如何定义数组 ?</p><p>如何访问数组的元素</p><p>掌握遍历数组的元素</p><p>练习 1:</p><p>定义一个 User 类, 有用户名和密码两个字段, 要求用户名长度必须大于 6 个字符,否则抛出用户名不合法的异常</p><p>练习 2:</p><p>定义一个存储 10 个 int 类型数据的数组, 从键盘上输入 10 个整数给数组的元素赋值</p><p>把数组的元素打印到屏幕上, 要求 for 循环/foreach 循环</p><p>找出数组中最大值元素的下标,打印出来</p><p><strong>3.3</strong></p><p><strong>数组是一种引用数据类型</strong></p><p>数组可以作为方法的返回值类型, 也可以作为方法的参数类型</p><p>数组作为方法参数时, 在方法体中修改形参数组元素值,实际上也是修改实参数组元素值; 在方法体中对形参数组重新赋值,形参数组指向了新的数组.</p><figure><img src="'+ln+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.4</strong></p><p><strong>可变长参数</strong></p><p>定义一个方法,可以接受任意个数据, 可以使用可变长参数</p><p>定义:</p><p>方法名( 参数类型 参数名 ,   类型 … 参数 )</p><p>说明:</p><ol><li>一个方法最多有一个可变长参数</li><li>可变长参数只能放在参数列表的最后</li><li>在方法体中, 把可变长参数当作数组使用即可</li></ol><figure><img src="'+cn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>//感觉可变参数直接变成数组了</p><p><strong>3.5</strong></p><p><strong>数组扩容</strong></p><p>当定义了数组之后 ,数组的长度就确定了,即数组存储元素的个数就确定了, 如果想要在数组中保存更多的数据, 就需要对数组进行扩容.</p><p>数组扩容:</p><ol><li>定义一个更大的数组</li><li>把原来数组的内容复制到新的数组中</li><li>让数组名指向新的数组</li></ol><figure><img src="'+rn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第二种方法</p><figure><img src="'+dn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+un+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第 3 种方法</p><figure><img src="'+gn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.6</strong></p><p><strong>数组的特点</strong></p><p>优点:</p><p>数组可以通过索引值(下标)可以实现数组元素的随机访问</p><p>缺点:</p><p>向数组中添加元素/删除元素时,效率比较低</p><p>应用场景:</p><p>以查询访问为主, 很少进行添加/删除时,选择数组存储这些数据</p><p><strong>3.7</strong></p><p><strong>对象数组</strong></p><p>数组中存储的是引用类型数据,就是对象数组</p><p>对象数组的元素实际上存储的是对象的引用</p><p>演示:购物车</p><p><strong>3.8</strong></p><p><strong>二维数组</strong></p><p>二维数组的每个元素又是一个数组</p><p>数组的数组就是二维数组</p><figure><img src="'+kn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+fn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.9 Arrays</strong></p><p><strong>工具类</strong></p><figure><img src="'+mn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.10</strong></p><p><strong>数组的几个算法</strong></p><p><strong>3.10.1</strong></p><p><strong>冒泡排序算法</strong></p><figure><img src="'+bn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.10.2</strong></p><p><strong>选择排序算法</strong></p><figure><img src="'+vn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3.10.3</strong></p><p><strong>二分查找算法</strong></p><p>小结:</p><ol><li>数组是一个引用类型, 可以作为方法的返回值类型,也可以作为方法的参数类型, 注意数组是方法参数类型时, 修改形参数组的元素, 给形参数组重新赋值</li><li>掌握可变长参数如何定义, 如何使用</li><li>掌握数组扩容的方法</li><li>理解数组的特点</li><li>学会对象数组的创建与遍历</li><li>学会二维数组的创建与遍历</li><li>学会 Arrays 工具类的常用方法: toString(), copyOf() , sort(), binarySeach()</li><li>了解冒泡排序的原理, 在面试前掌握算法的实现</li></ol><p>练习 1:</p><p>定义一个方法, 实现对形参数组的逆序</p><p>练习 2:</p><p>定义一个方法, 返回一个长度为 10 的整数数组, 对数组的元素进行随机的初始化 100 内的正整数, 要求数组中的元素不重复</p><p>练习 3:</p><p>定义一个用户类 User,包括用户名和密码两个字段</p><p>定义一个用户管理类 UserManager, 定义一个数组保存用户信息, 定义一个方法 add(User)向数组中添加一个用户, 定义方法 usernameExist(String)判断用户名是否存在, 定义方法 userExist(User)判断用户是否存在</p><p>定义测试类, 提示用户选择操作: 1 用户注册, 2 用户登录,3 退出程序. 如果用户选择 1 表示注册, 提示输入用户名, 判断用户名是否存在,如果存在提示用户重新输入, 提示用户输入密码, 根据用户名和密码创建 user 对象添加到数组中; 如果用户选择 2 表示登录, 提示输入用户名和密码, 判断用户是否存在;</p><p>练习 4:</p><p>定义一个 Attackable 攻击接口,封装 attach()攻击的行为</p><p>定义一个 Movable 接口, 封装 move()移动的行为</p><p>定义一个 Weapon 武器类, 武器是可攻击的,但是不同的武器攻击方式不同</p><p>定义一个 Tank 类继承 Weapon, 坦克是可移动的</p><p>定义一个 Flighter 战斗机类继承 Weapon, 战斗机也是可移动的</p><p>定义一个 Missile 导弹类继承 Weapon, 导弹不能移动</p><p>定义一个 Army 军队类, 军队有武器库, 使用数组来保存若干的武器模拟武器库; 向武器库中添加武器, 从武器库中删除武器, 给所有的武器下达攻击指令, 给能移动的武器下达移动指令.</p><h1 id="第四章-常用类" tabindex="-1"><a class="header-anchor" href="#第四章-常用类" aria-hidden="true">#</a> 第四章 常用类</h1><p><strong>4.1</strong></p><p><strong>与字符串相关的类</strong></p><p><strong>4.1.1 String</strong></p><p><strong>类</strong></p><p>java.lang.String 类表示字符串的类</p><ol><li><p>如何创建 String 对象(构造方法)</p></li><li><p>常用方法</p></li><li><p>正则表达式</p></li><li><p>字符串判等</p></li><li><p>String 字符串对象不可变</p></li></ol><p><strong>4.1.2 StringBuilder/StringBuffer</strong></p><p><strong>类</strong></p><p>可变的字符串</p><p>如果频繁进行字符串连接,使用 StringBuilder/StringBuffer</p><p>这两个类量常用方法是: append()</p><p><strong>4.2</strong></p><p><strong>包装类</strong></p><p>在 java 中, 系统为每一个基本类型都提供 了 一个对应的包装类型</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>为什么提供包装类?? 为了编程方便</p><p>包装类在 java.lang 包中</p><figure><img src="'+hn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Atomiclnteger</p><p>在多线程程序中，使用 int 类型变量进行自增与自减时，可能不准确.使用该类进行自增与自减</p><p>BigDecimal</p><p>在进行财务计算/科学计算时，要求精度非常高，就这用这个类</p><p>包装类对象的创建(构造方法)</p><p>包装类的基本操作</p><p>装箱与拆箱</p><p>总结:</p><p>1)熟练掌握 String 对象创建的各种方式</p><ol start="2"><li><p>熟练掌握 String 的常用操作</p></li><li><p>理解字符串判等,   ==   equals()   字符串字面量保存在常量池中</p></li></ol><p>4)理解 String 对象是不可变的</p><p>5)记住 StringBuilder/StringBuffer 是可变 的字符串, 常用的操作是 append()</p><p>6)记住系统为每个基本类型提供的对应包装类, 理解为什么提供包装类</p><ol start="7"><li><p>学会创建包装类对象, 掌握包装类的基本操作</p></li><li><p>理解装箱与拆箱, -128~127 之间整数装箱采用享元模式</p></li></ol><p>练习 1:</p><p>验证用户输入的密码必须包括字母/数字, 要求密码的长度大于 6 个字符</p><p>练习 2:</p><p>根据身份证号, 判断人的出生日期, 判断人的性别(第 17 位)</p><p>练习 3:</p><p>有一个字符串 &quot; lisi, 18,男;wangwu,20,女;feifei,28,女;yanmingjie,34,男&quot;;根据字符串中人的信息创建 Person 对象, 添加到数组中.</p><ol><li>创建 Person 类</li><li>创建一个存储 Person 对象的数组</li><li>把字符串中的信息分离出来</li><li>遍历数组中的信息, 创建 Person 对象, 添加到数组中</li></ol><p>练习 4:</p><p>int/Integer/String 之间的相互转换</p><p><strong>4.3</strong></p><p><strong>日期类</strong></p><p>java.util.Date 类</p><p>java.text.SimpleDateFormat 对日期格式化</p><p><strong>4.4</strong></p><p><strong>数学类</strong></p><p>java.lang.Math</p><p>java.math.BigDecimal</p><p>java.util.Random</p><h1 id="第五章-集合" tabindex="-1"><a class="header-anchor" href="#第五章-集合" aria-hidden="true">#</a> 第五章 集合</h1><p><strong>5.1 Collection</strong></p><p><strong>集合概述</strong></p><p>集合是用来存储引用类型数据的容器</p><p>集合主要有两大类:</p><p>Collection 集合: 存取数据时是单个存取,</p><p>Map 集合: 是按&lt;键,值&gt;对的形式存取数据, &lt;”lisi”,18&gt; &lt;”feifei”, 28&gt;</p><p>java.util.Collection 集合框架</p><figure><img src="'+yn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>5.2 Collection</strong></p><p><strong>5.3 List</strong></p><p><strong>集合</strong></p><p>List 特点: 有序,可重复</p><p>List 集合为每个元素指定了一个索引值, 主要增加了针对索引值的操作</p><p>练习:</p><p>定义一个 List 集合, 存储 Employee 员工信息</p><p>向集合中添加以下加工:</p><p>&lt;lisi, 18,5800&gt;</p><p>&lt;wangwu, 28,9000&gt;</p><p>&lt;zhaoliu, 38,8800&gt;</p><p>&lt;yanmingjie, 35,10000&gt;</p><p>在 wangwu 工人前面插入一个员工&lt;feifei, 28,6666&gt;</p><p>删除 zhaoliu</p><p>迭代遍历所有的员工信息</p><p><strong>5.4 ArrayList</strong></p><p><strong>与</strong></p><p><strong>Vector</strong></p><ul><li><ol><li>底层都是数组, Vector 是线程安全的, Arraylist 不是线程安全的</li></ol></li><li><ol start="2"><li>初始化容量: 10</li></ol></li><li><ol start="3"><li>ArrayList 扩容: 1.5 倍速, Vector 扩容: 2 倍</li></ol></li></ul><p><strong>5.5 LinkedList</strong></p><p>底层是双向链表</p><p><strong>5.5.1</strong></p><p><strong>单向链表</strong></p><figure><img src="'+_n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>5.5.2</strong></p><p><strong>双向链表</strong></p><figure><img src="'+Sn+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>5.5.3 LinkedList</strong></p><p><strong>新增的方法</strong></p><p>增加了针对头与尾的操作</p><table><thead><tr><th>void</th><th>[addFirstaddFirst-E-) ( E( e)把元素e添加到列表的头部</th></tr></thead><tbody><tr><td>void</td><td>[addLastaddLast-E-) ( E( e) 把元素e添加到最后</td></tr><tr><td>E(</td><td>[getFirstgetFirst--) () 返回第一个元素</td></tr><tr><td>E(</td><td>[getLastgetLast--) () 返回最后一个元素</td></tr><tr><td>E(</td><td>[removeFirstremoveFirst--) () 删除第一个元素</td></tr><tr><td>E(</td><td>[removeLastremoveLast--) () 删除最后一个元素</td></tr><tr><td>E</td><td>[peekpeek--) () 返回第一个元素</td></tr></tbody></table><p>有时, 使用 LinkedList 模拟栈, 栈的特点:后进先出</p><table><thead><tr><th>void</th><th>[pushpush-E-) ( E( e) 模拟压栈, 把元素e添加列表的头部</th></tr></thead><tbody><tr><td>E(</td><td>[poppop--) () 模拟出栈, 把列表的第一个元素删除</td></tr></tbody></table><p>使用 offer(e), poll()模拟队列, 队列特点: 先进先出,</p><table><thead><tr><th>boolean</th><th>[offeroffer-E-) ( E( e) 模拟入队, 把元素e添加到列表的尾部</th></tr></thead><tbody><tr><td>E(</td><td>[pollpoll--) () 模拟出队, 把列表的第一个元素删除</td></tr></tbody></table><p><strong>5.6 Set</strong></p><p><strong>集合</strong></p><p>特点:无序,不可重复</p><ul><li><p>HashSet</p></li><li><ol><li>HashSet 底层是 HashMap</li></ol></li><li><ol start="2"><li>向 hashset 中添加元素,实际上是把该元素作为键添加到底层的 HashMap 中</li></ol></li><li><ol start="3"><li>HashSet 就是 HashMap 键的集合</li></ol></li><li><p>TreeSet</p></li><li><ol><li>TreeSet 实现了 SortedSet 接口, 可以对元素自然排序, 要求集合中的元素必须是可比较的</li></ol></li><li><p>(1)在创建 TreeSet 时,可以指定 Comparator 比较器</p></li><li><p>(2)没有指定 Comparator 比较器, 要求元素的类实现 Comparable 接口</p></li><li><ol start="2"><li>TreeSet 底层是 TreeMap</li></ol></li><li><p>向 TreeSet 添加元素,实际上是把该元素作为键添加到了底层的 TreeMap 中</p></li><li><p>TreeSet 实际上就是 TreeMap 键的集合</p></li></ul><p>小结:</p><ol><li>掌握创建 Date 日期对象, 对 Date 日期进行格式化, 把日期字符串转换为 Date 对象</li><li>了解 Math 类定义了三角函数, 知道 BigDecimal 类可以进行精确的计算, 能够使用 Random 类生成随机数</li><li>能够画出 Collection 集合框架结构图, 记住每个集合的特点</li><li>掌握 Collection 集合的基本操作: 添加, 删除, 判断是否存在, 迭代遍历/删除</li><li>掌握 List 集合特点, 增加了针对索引值的操作</li><li>记住 ArrayList, Vector 与 LinkedList 的特点</li><li>了解单向链表/双向链表的结构</li><li>记住 LinkedList 增加针对第一个元素/最后一个元素的操作</li><li>记住 Set 集合特点, HashSet 集合特点, TreeSet 集合特点</li></ol><p>练习 1:</p><p>总结 Collection 各个集合的应用场景</p><p>练习 2:</p><p>把购物车改为使用集合存储产品</p><p>练习 3:</p><p>有字符串:”01,勇哥,100;02,杜哥,95;03,明哥,90;04,菲菲,5;05,杨哥,60”</p><ol><li>把字符串中的学生信息分离出来,</li></ol><p>01,勇哥,100</p><p>02,杜哥,95</p><p>…….</p><p>这些数据分别是学号, 姓名,成绩</p><ol><li>创建 List 集合, 根据分离出来的学生信息创建学生对象, 添加到 List 集合中</li><li>通过迭代分别打印集合中的学生信息</li><li>判断集合中是否存在 姓名为”明哥”的学生</li><li>对集合中的学生按成绩降序排序</li><li>通过循环打印集合中的学生信息</li><li>删除姓名为”明哥”的学生</li><li>通过 foreach 循环打印集合中学生的信息</li></ol><p>练习 4:</p><ol><li>创建 Product 产品类, 包括名称, 价格, 数量三个字段</li></ol><p>2)创建 TreeSet 集合, 存储 Product 产品,默认按价格升序排序, 向集合中添加一些 Product 对象</p><p>3)对 TreeSet 集合中的产品根据数量降序再次排序</p><p><strong>5.7 Collection</strong></p><p><strong>小结</strong></p><p>Collection 存储数据时是单个存储的,只能存储引用类型数据</p><p>add() , remove() , contains() , iterator()</p><p>----List 集合</p><p>有序, 可重复</p><p>为每个元素指定了一个索引值,</p><p>add(index, o), remove(index),   get(index), sort(Comparator)</p><p>--------ArrayList</p><p>--------Vector</p><p>底层是数组, 访问快, 添加/删除慢</p><p>初始化容量: 10</p><p>扩容: ArrayList 是 1.5 倍, Vector 是 2 倍</p><p>Vector 是线程安全的, ArrayList 不是线程安全的</p><p>--------LinkedList</p><p>底层是双向链表, 添加/删除效率高, 访问慢</p><p>******************List 集合如何选择</p><p>ArrayList 应用于以查询访问为主,很少进行添加/删除操作</p><p>LinkedList 应用于 频繁的进行添加/删除操作的情况</p><p>----Set 集合</p><p>无序, 不可重复</p><p>--------HashSet</p><p>底层是 HashMap</p><p>HashSet 就是 Hashmap 键的集合</p><p>--------TreeSet</p><p>底层是 TreeMap</p><p>TreeSet 就是 TreeMap 的键 的集合</p><p>TreeSet 实现了 SortedSet 接口, 可以对元素自然排序, 要求元素必须是可比较的</p><ol><li>创建 TreeSet 时指定 Comparator 比较器</li><li>如果没有指定 Comparator 比较器, 元素的类要实现 Comparable 接口</li></ol><p>*************如何选择 HashSet 还是 TreeSet</p><p>如果不需要进行排序选择 HashSet</p><p>如果需要根据某个字段排序,选择 TreeSet</p><p>===================注意</p><p>List 集合与 HashSet 集合中判断是否同一个元素, 需要调用对象的 equals()方法, 元素的类需要重写 equals()方法</p><p>TreeSet 集合判断是否同一个元素,根据 Comparator/Comparable 的比较结果是否为 0 判断,如果比较结果为 0 就认为是同一个元素</p><p><strong>5.8</strong></p><p><strong>泛型</strong></p><p>泛型就是把数据类型作为参数传递</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>在 <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token operator">/</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>接口中 通过泛型指定比较元素的数据类型

在 <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>集合中<span class="token punctuation">,</span>通过泛型指定存储元素的数据类型
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>泛型的好处是:</p><p>在编译时可以进行数据类型的检查</p><p>注意,在集合泛型中, 在定义集合时泛型才有作用:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>约束 collection 集合中只有存储 String 字符串, 在赋值时,ArrayList 后面的泛型不需要写, 如果要写也要和前面的泛型一样</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collection</span>   collection22 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果前面定义集合时,没有泛型约束,而在赋值时指定了 ArrayList 泛型为 String, 不管用. collection22 集合可以存储任意的对象</p><p><strong>5.9 Collections</strong></p><p><strong>工具类</strong></p><p>java.util.Collections 工具类提供了一些对 Collection 集合进行操作的方法</p><p>Collections 工具类中有一组操作: synchronizedXXX(XXX)可以把 XXX 集合由不是线程安全的集合转换为线程安全的集合:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">synchronizedCollection</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span>

<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span>

<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span>

<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">synchronizedSet</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是, 我们现在开发多线程程序,基本不再使用这些方法, 而是直接使用 java.util.concurrent 包中线程安全的集合类, 如：线程安全的 List 集合: copyonWriteArrayList,. 线程安全的 Set 集合: copyOnWriteArraySet, concurrentSkipListSet</p><p><strong>5.10 Map</strong></p><p><strong>概述</strong></p><p>Map 是按&lt;键,值&gt;对的形式存储数据的</p><p>java.util.Map 集合框架:</p><figure><img src="`+wn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>5.11 Map</strong></p><p><strong>的基本操作</strong></p><p><strong>5.12 HashMap</strong></p><figure><img src="'+jn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>HashMap 底层是哈希表(散列表), 哈希表就是一个数组,数组的每个元素是一个单向链表; 在 put( k, v )添加键值对时, 先根据键的 hashCode 计算数组的索引值(下标), 访问数组元素, 如果该元素为 null, 创建一个新的结点保存到数组元素中; 如果数组元素不为 null, 遍历单向链表的各个结点, 如果有某个结点的 key 与当前的键 equals 相等, 就使用新的值 v 替换结点原来的 value 值, 如果整个链表中所有结点的 key 都不匹配, 就创建一个新的结点插入到链表的头部.</p><p><strong>5.13 HashTable</strong></p><ul><li><p>HashTable</p><ol><li>底层都是哈希表(散列表), 但是 HashTable 是线程安全的, HashMap 不是线程安全的</li><li>HashMap 的父类是 AbstractMap, HashTable 的父类是 Dictionary</li><li>HashMap 默认的初始化容量: 16 , HashTable 默认初始化容量: 11</li><li>加载因子: 0.75 , 当&lt;键,值&gt;对的数量 大于   数组的容量(哈希桶的容量) * 加载因子时 , 数组要扩容</li><li>HashMap 扩容默认: 2 倍大小;   HashTable 扩容: 2 倍 + 1</li><li>HashMap 的键与值都可以为 null, HashTable 的键与值都不能为 null</li><li>HashMap 在创建时, 可以指定一个初始化容量, 系统会调整为 2 的幂次方, 为了快速计算出数组的下标</li></ol></li><li><p>HashTable 也可以指定初始化容量, 系统不调整</p></li></ul><p><strong>5.14 Properties</strong></p><p>Properties 继承了 HashTable, 键与值都是 String</p><p>经常用于设置/读取系统属性, setPropertty(属性名, 属性值) , getProperty(属性名)</p><p>使用 Properties 读取配置文件</p><p><strong>5.15 TreeMap</strong></p><ol><li>TreeMap 实现了 SortedMap, 可以根据键自然排序, 排序原理是二叉树原理</li></ol><figure><img src="'+xn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>TreeMap 的键必须是可比较的</li></ol><p>指定 Comparator 比较器</p><p>如果没有 Comparator 比较器, 元素的类实现 Comparable 接口</p><p><strong>5-16 Map</strong></p><p><strong>小结</strong></p><p>Map 按&lt;键,值&gt;对形式存储数据</p><p>put( k ,v)   containsKey(k)   containsValue(v)   get(k)   remove(k)</p><p>keyset()   values()   entrySet()</p><p>---- HashMap</p><p>工作原理</p><p>----HashTable</p><p>与 HashMap 的异同点</p><p>--------Properties</p><p>键与值都是 String 字符串</p><p>设置/读取系统属性值</p><p>----TreeMap</p><p>可以根据键自然排序</p><p>************************如何选择?</p><p>如果不需要根据键排序就选择 HashMap</p><p>如果需要根据键排序,就选择 TreeMap</p><p>==================注意:</p><p>HashMap 中的键需要重写 equals()/hashCode()方法</p><p>TreeMap 中的键是根据 Comparator/Comparable 的比较结果是否为 0 来判断是否相同</p><p>小结:</p><ol><li>知道泛型是什么 , 泛型的优点</li><li>了解 Collections 工具类有一组 synchronizedXXX()可以把不是线程安全的集合转换为线程安全的集合</li><li>能够画出 Map 集合的结构图</li><li>掌握 Map 的基本操作</li><li>理解 HashMap 的工作原理</li><li>记住 HashTable 与 HashMap 的异同点</li><li>学会使用 Properties 读取配置文件的属性</li><li>了解 TreeMap 键的排序采用二叉树原理</li><li>明确 TreeMap 中的键必须是可比较的, 要么指定 Comparator 比较器, 如果没有 Comparator 比较器, 键要实现 Comparable 接口</li></ol><p>练习 1:</p><p>用户登录, 用户管理类使用 Map 保存&lt;用户名,密码&gt;</p><p>练习 2:</p><p>/** 把 下面的数据定义一个集合保存起来</p><ul><li><p>[{&quot;time&quot;:&quot;2018-08-23 09:58:40&quot;,</p></li><li><p>&quot;ftime&quot;:&quot;2018-08-23 09:58:40&quot;,</p></li><li><p>&quot;context&quot;:&quot;华伟家园东门头房快递服务中心妈妈驿站已发出自提短信,请上门自提,联系电话 17662528999&quot;,</p></li><li><p>&quot;location&quot;: null},</p></li><li><p>{&quot;time&quot;:&quot;2018-08-23 09:57:40&quot;,</p></li><li><p>&quot;ftime&quot;:&quot;2018-08-23 09:57:40&quot;,</p></li><li><p>&quot;context&quot;:&quot;快件已到达华伟家园东门头房快递服务中心妈妈驿站,联系电话 17662528999&quot;,</p></li><li><p>&quot;location&quot;: null},</p></li><li><p>......</p></li><li><p>]</p></li></ul><ul><li></li></ul><p>*/</p><h1 id="第六章-io-流" tabindex="-1"><a class="header-anchor" href="#第六章-io-流" aria-hidden="true">#</a> 第六章 IO 流</h1><p><strong>1.1 概述</strong></p><p>流是有起点和终点的有序字节序列</p><p>流的分类:</p><p>输入流/输出流, 是当前程序为参照点, 程序从外面读数据这是输入流, 把程序的数据保存到外面是输出流</p><p>字节流/字符流, 如果是以字节为单位处理流中的数据就是字节流, 如果是以字符为单位处理流中的数据就是字符流</p><p>节点流/处理流, 如果直接从设备(数据源)上读写数据就是节点流, 处理流是对节点流的包装</p>',719),as={href:"http://java.io",target:"_blank",rel:"noopener noreferrer"},ps=t('<p><strong>1-2 FileInputStream/FileOutputStream</strong></p><p>以字节为单位读写文件内容</p><p><strong>1-3 FileReader/FileWriter</strong></p><p>以字符为单位读写文件内容</p><p>只能读写文本文件, 并且要求文本文件的编码格式与当前环境编码格式兼容</p><p><strong>1-4 InputStreamReader/OutputStreamWriter</strong></p><p>当文本文件编码与当前环境编码不兼容时, 使用这个转换流</p><p>InputStreamReader 把字节流以指定的编码转换为字符流</p><p>OutputStreamWriter 可以把字符转换为指定格式的字节流</p><p><strong>1-5 BufferedReader/BufferedWriter</strong></p><figure><img src="'+Cn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>1-6 ObjectInputStream/ObjectOutputStream</strong></p><p>对象序列化:</p><p>把对象转换为 01 二进制序列就是对象序列化</p><p>对象反序列化</p><p>把一组 01 二进制序列转换为对象</p><p>注意:</p><p>对象序列化/反序列化前提是对象的类要实现 Serializable 接口,该接口是一个标志性接口,没有任何方法</p><p>ObjectOutputStream 类 可以把对象序列化,把序列化后二进制保存到文件中</p><p>ObjectInputStream 类可以从文件读取 01 序列,把 这组 01 序列转换为对象(反序列化)</p><p>一般情况下, 类实现了 Serializable 接口后, 手动的添加一个序列化版本号字段:</p><p>private static final long serialversionUID = 2332956456465L;</p><p><strong>1-7 PrintStream/PrintWriter</strong></p><p>打印字节流/打印字符流</p><p><strong>1-8 File</strong></p><p><strong>类</strong></p><p>读取文件内容使用 IO 流, 操作文件/文件夹使用 File 类, 如创建/遍历/删除文件夹, 查看文件的相关属性等操作</p><p>小结:</p><ol><li>记住流的概念及分类</li><li>掌握 FileInputStream/FileOutputStream 字节流实现文件读写</li><li>能够使用 FileInputStream/FileOutputStream 字节流类实现文件复制, 异常处理, 手动/自动关闭流</li><li>掌握 FileReader/FileWriter 字符流类的使用</li><li>能够使用 FileReader/FileWriter 字符流类实现文本文件的复制,异常处理,手动/自动关闭流</li><li>初步掌握转换流的使用</li><li>了解缓冲流的工作原理</li><li>掌握对象序列化/反序列化</li><li>了解打印流</li><li>了解 File 类</li></ol><h1 id="第七章-线程" tabindex="-1"><a class="header-anchor" href="#第七章-线程" aria-hidden="true">#</a> 第七章 线程</h1><p><strong>7-1</strong></p><p><strong>线程概述</strong></p><p>进程</p><p>进程就是操作系统运行的一个程序</p><p>线程</p><p>线程就是进程的一个执行单元,一条执行路径</p><p>如启动 360 安全卫士就是打开一个进程, 它的电脑体检/木马查杀/系统清理等就是这个进程的几个执行单元, 每个执行单元就是一个线程</p><p>迅雷就是一个进程, 可以同时下载多部电影, 每一部电影的下载就是一条执行路径,就是迅雷进程的一个线程</p><p>一个进程至少有一个线程, 如果进程有多个线程,则它就是多线程应用程序</p><p>每个线程都有独立的栈空间</p><figure><img src="'+En+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>主线程</p><p>JVM 启动主线程,主线程运行 main 方法</p><p>用户线程</p><p>开启的新的线程, 也称子线程</p><p>守护线程</p><p>守护线程是为其他线程提供服务的线程,不能独立运行,当 JVM 中只有守护线程时,JVM 会退出.   垃圾回收器就是一个守护线程</p><p><strong>7-2</strong></p><p><strong>创建线程的方式</strong></p><p>创建线程依赖 java.lang.Thread 类, Thread 就是一个线程类</p><p><strong>7.2.1</strong></p><p><strong>继承</strong></p><p><strong>Thread</strong></p><p>class SubThread   extends   Thread{</p><p>public void run (){</p><p>子线程要执行的代码</p><p>}</p><p>}</p><p>SubThread t1 = new SubThread();</p><p>t1.start();</p><p><strong>7.2.2</strong></p><p><strong>实现</strong></p><p><strong>Runnable</strong></p><p><strong>接口</strong></p><p>class Prime1 implements Runnable{</p><p>public void run(){</p><p>用户线程执行的代码</p><p>}</p><p>}</p><p>Thread t2 = new Thread( new   Prime1() );</p><p>t2. start()</p><p><strong>7.2.3</strong></p><p><strong>实现</strong></p><p><strong>Callable</strong></p><p><strong>接口</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Prime2</span> <span class="token keyword">implements</span>   <span class="token class-name">Calllable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

<span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">throws</span>   <span class="token class-name">Exception</span><span class="token punctuation">{</span>

子线程执行的代码

<span class="token keyword">return</span>   xxx<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Prime2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> task <span class="token punctuation">)</span><span class="token punctuation">;</span>

t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

可以获得子线程返回的结果

task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>7-3</strong></p><p><strong>线程的常用操作</strong></p><p><strong>7-4</strong></p><p><strong>线程的生命周期</strong></p><figure><img src="`+Tn+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>7-5</strong></p><p><strong>线程调度</strong></p><p><strong>7.5.1</strong></p><p><strong>优先级</strong></p><p>线程优先级越高, 获得 CPU 执行权的机率越大</p><p>取值范围: 1 ~ 10</p><p>默认值: 5</p><p>setPriority() / getPriority()</p><p><strong>7.5.2</strong></p><p><strong>睡眠</strong></p><p>Thread.sleep( millis )</p><p>静态方法,由类名调用</p><p>睡眠的单位是毫秒</p><p>有受检异常需要预处理</p><p>sleep()方法所在的线程睡眠</p><p><strong>7.5.3</strong></p><p><strong>中断</strong></p><p>t1.interrupt()</p><p>一般情况下,是把处于睡眠/等待中的线程给中断</p><p><strong>7.5.4</strong></p><p><strong>线程合并</strong></p><p>t1.join() 在当前线程中加入 t1 线程, 当前线程转为等待状态, 等到 t1 执行完后当前线程转为就绪状态</p><p><strong>7.5.5</strong></p><p><strong>让步</strong></p><p>Thread.yield(), 把运行的线程转为就绪状态,重新抢 CPU 执行权</p><p><strong>7.5.6</strong></p><p><strong>线程终止</strong></p><p>t1.stop(),   已过时</p><p>一般通过修改线程标志的方式让线程运行结束</p><p><strong>7.6</strong></p><p><strong>线程同步</strong></p><ol><li>线程安全问题</li></ol><p>当多个线程同时操作堆区或者方法区的某个数据时, 可能会出现数据不一致 的现象, 称为线程安全问题</p><p>2 出现线程安全问题怎么办?</p><p>每个线程都 访问自己的局部变量</p><p>如果多个线程必须同时操作实例变量/静态变量时, 可以采用线程同步技术</p><p>3 线程同步技术解决什么问题?</p><p>当一个线程在操作期间,不允许其他的线程加入</p><p>某一段代码在某一时刻只能由一个线程执行</p><p>4 如何同步?</p><p>语法:</p><p>synchronized( 锁对象 ) {</p><p>同步代码块</p><p>}</p><p>工作原理:</p><ol><li>线程要执行同步代码块, 必须先获得锁对象</li><li>任意对象都可以作为锁对象, 每个对象有一个内置锁</li><li>某一时刻, 锁对象最多只能被一个线程持有</li><li>如果线程获得了锁对象后,会一直持有, 直到执行完同步代码块后才释放</li></ol><p>场景描述: 假设有线程 A 和线程 B 两个线程都想要执行同步代码块</p><ol><li>线程 A 获得 CPU 执行权, 获得了锁对象后, 开始执行同步代码块</li><li>线程 A 在执行同步代码块期间, CPU 执行权被线程 B 抢走了, 线程 A 转为就绪状态</li><li>线程 B 获得 CPU 执行权, 也想要执行同步代码块, 必须先获得锁对象, 现在锁对象被线程 A 持有, 线程 B 转到等待锁对象池中进行阻塞</li><li>线程 A 重新获得 CPU 执行权, 执行完同步代码块后释放锁对象</li><li>等待锁对象池中的线程 B 获得了锁对象,转为就绪状态</li></ol><p>5 同步代码块</p><p>同步代码块想要实现同步,必须使用同一个锁对象</p><p>只要使用了同一个 锁对象的同步代码块就可以实现同步</p><p>经常定义一个常量 对象作为锁对象</p><p>有时使用 this 对象作为锁对象</p><p>有时也使用当前类的运行时类对象作为锁对象, 如 Test07.class, 有人称它为类锁</p><p>6 同步方法</p><p>直接使用 synchronized 修饰的方法, 把整个方法体都作为同步代码块</p><p>修饰实例方法, 默认的锁对象是 this 对象</p><p>修饰静态方法, 默认的锁对象是当前类的运行时类, 如 Test07.class</p><p>7 死锁</p><p>在线程同步时, 由于获得锁对象的顺序不一致导致线程出现相互等待的情况,称为死锁</p><p>如何避免出现死锁?</p><p>保证获得 锁对象的顺序一致即可</p><p>小结:</p><ol><li>理解线程的相关概念: 进程, 线程, 主线程, 用户线程, 守护线程</li><li>知道创建线程的三种方式, 掌握其中的两种: 继承 Thread 类, 实现 Runnable 接口</li><li>了解线程的基本操作,   掌握以下方法的使用:</li></ol><p>Thread.currentThread()</p><p>getName()</p><p>Thread.sleep()</p><p>通过标志终止线程的方法</p><ol><li>能够画出线程的状态图(线程生命周期)</li><li>掌握线程同步技术</li></ol><p>什么是线程安全问题?</p><p>出现线程安全问题怎么办??</p><p>理解线程同步技术解决什么问题?</p><p>如何同步?</p><p>同步代码块的特点, 常用的锁对象有哪些?</p><p>同步方法</p><p>死锁</p><p><strong>7.7</strong></p><p><strong>生产者消费者设计模式</strong></p><p>设计模式就是别人总结的一套解决方案,这大解决方案被大多数人熟知与认可.</p><p>生产者消费者设计模式解决了数据的平衡问题</p><figure><img src="'+zn+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>练习:</p><p>创建两个线程, 一个线程打印奇数,一个线程打印偶数,实现交替打印</p><p><strong>7.8 Timer</strong></p><p>练习:</p><p>创建两个线程, 一个线程打印 100 个数, 另一个线程打印 10 个数,实现交替打印</p><p>线程 1:1</p><p>线程 1:2</p><p>……</p><p>线程 1:100</p><p>线程 2:101</p><p>……</p><p>线程 2:110</p><p>线程 1:111</p><p>线程 1:112</p><p>……</p><p>线程 1:210</p><p>线程 2:211</p><p>……</p><p>线程 2:220</p><h1 id="第八章-反射" tabindex="-1"><a class="header-anchor" href="#第八章-反射" aria-hidden="true">#</a> 第八章 反射</h1><p><strong>8.1</strong></p><p><strong>概述</strong></p><p>反射就是根据字节码文件, 反射类的信息,字段,方法,构造方法等类的内容, 根据字节码文件创建对象, 调用方法的技术</p><p>反射的基础 是 Class 对象</p><p>把一组小狗可以抽象为 Dog 类, 把一组小猪抽象类 Pig 类, 把一组人抽象为 Person 类, 把 Dog/Pig/Person/String/System 等所有的类抽象为 Class 类, Class 类描述所有的类的共同特征</p><p>如何获得 Class 对象?</p><ol><li>每个类都有 class 属性,</li><li>每个对象都有 getClass()方法</li><li>Class.forName( 完整类名 )</li></ol><p><strong>8.2</strong></p><p><strong>反射类的信息</strong></p><p>java.lang.reflect 包中有反射相关的类</p><p>class1.getModifiers()       返回类的修饰符</p><p>class1.getName()           返回完整类名</p><p>class1.getSimpleName()       简易类名</p><p>class1.getSuperClass()       父类</p><p>class1.getInterfaces()       接口</p><p><strong>8.3</strong></p><p><strong>访问字段</strong></p><p>class1.getField( 字段名 ) 返回指定名称的公共字段</p><p>class1.getDeclaredField(字段名)     返回指定名称的字段</p><p>class1.newInstance()       创建实例</p><p>field.set( 实例名, 字段值)         设置字段的值</p><p>field.get( 实例名 ) 返回字段的值</p><p><strong>8.4</strong></p><p><strong>调用方法</strong></p><p>class1.getMethod( 方法名, 方法的参数类型列表)   反射方法</p><p>method.invoke( 实例名, 方法的实参列表)</p><p><strong>8.5 IO+Properties+Reflect</strong></p><p>有时会把类名保存到配置文件中, 通过 Properties 读取配置文件的类名 , 通过反射创建对象</p><h1 id="第九章-socket-编程" tabindex="-1"><a class="header-anchor" href="#第九章-socket-编程" aria-hidden="true">#</a> 第九章 Socket 编程</h1><p>1)开发网络程序, 需要知道对方计算机的 IP 地址, 端口号, 通讯协议</p><p>2)现在网络采用的是 TCP/IP 传输协议簇</p><p>TCP ,面向连接的可靠的传输控制协议, 类似于打电话, 三次握手机制</p><p>UDP, 用户数据报协议, 类似于对讲机</p><p>B/S, Browser 浏览器/Server 服务器</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">ServerSocket</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChatServer</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
<span class="token comment">// 创建服务器器端, 注册当前程序的端口号</span>
<span class="token class-name">ServerSocket</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 接受客户端的连接，产⽣生⼀一个Socket</span>
<span class="token class-name">Socket</span> socket <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取Socket的输⼊入流, 就是通过这个输入流获得客户端发送给服务器的数据</span>
<span class="token class-name">BufferedReader</span> socketReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取Socket的输出流, 就是通过该输出流, 服务器把数据发送给客户端</span>
<span class="token class-name">OutputStreamWriter</span> socketOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取键盘的输⼊入流,通过该输入流读取键盘上输入的数据</span>
<span class="token class-name">BufferedReader</span> keyboardReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 不断读取客户端数据</span>
<span class="token class-name">String</span> line <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> socketReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;客户端：&quot;</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;我说：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
line <span class="token operator">=</span> keyboardReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>line <span class="token operator">+</span> <span class="token string">&quot;\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
socketOut<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 关闭</span>
server<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetAddress</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">Socket</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStreamWriter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChatClient</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
<span class="token comment">// 建立TCP客户端与服务器的连接, 指定服务器的IP地址与程序对应的端口号</span>
<span class="token comment">//       Socket socket = new Socket(InetAddress.getLocalHost(), 9090);</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> addr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">64</span> <span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">88</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">115</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">//把192.168.141.2 IP地址转换为字节</span>
<span class="token class-name">InetAddress</span> address <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getByAddress</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取Socket输出流对象, 通过该流把数据发送给服务器</span>
<span class="token class-name">OutputStreamWriter</span> socketOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取Socket输入流对象, 通过该流获得服务器发送给客户端的数据</span>
<span class="token class-name">BufferedReader</span> socketReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取键盘输入流对象，读取数据</span>
<span class="token class-name">BufferedReader</span> keyboardReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> line <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;我说：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> keyboardReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>line <span class="token operator">+</span> <span class="token string">&quot;\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 刷新</span>
socketOut<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 读取服务器端返回的数据</span>
line <span class="token operator">=</span> socketReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;服务器：&quot;</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;我说：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小结:</p><p>1)努力掌握生产者消费者设计模式</p><p>2)初步学会使用 Timer 定时器类</p><p>3)理解反射(功能)是什么</p><p>4)掌握创建 Class 对象的方式</p><p>5)掌握如何反射类的父类, 接口</p><p>6)掌握通过反射访问字段, 先创建实例</p><p>7)掌握通过反射调用方法</p><p>8)了解 Socket 编程,</p><p>练习:</p><p>通过反射技术调用 String 类的 equals(Object)方法</p><p>已使用 Microsoft OneNote 2016 创建。</p>`,230);function ts(es,os){const a=o("ExternalLinkIcon");return i(),l("div",null,[Mn,n("p",null,[n("a",Bn,[s("java.io"),p(a)]),s("                   输入输出相关的类")]),qn,n("p",null,[n("a",Ln,[s("java.net"),p(a)]),s("                   网络相关的类")]),Fn,n("p",null,[n("a",On,[s("com.bjpowernode.chapter01.packages.p3.MyUtil.sm"),p(a)]),s("();")]),In,n("p",null,[n("a",Pn,[s("MyUtil.sm"),p(a)]),s("();")]),Hn,Rn,n("p",null,[s("|package com.bjpowernode.chapter01.packages.p2;"),Dn,s("/"),Un,s("/"),Jn,s("import com.bjpowernode.chapter01.packages.p3.MyUtil;       //是把被使用的类导入到当前文件中"),Wn,s("class Test02{"),Vn,s("public static void main(String[] args)     {"),Nn,s('System.out.println("在 p2 包中调用 p3 包中的 MyUtil 类的静态方法");'),Xn,s("//1)直接通过完整类名调用"),Kn,n("a",Gn,[s("com.bjpowernode.chapter01.packages.p3.MyUtil.sm"),p(a)]),s("();"),Qn,s("//2)先把其他包中的类导入,再使用简易类名调用"),Yn,n("a",Zn,[s("MyUtil.sm"),p(a)]),s("();"),$n,s("}"),ns,s("}|")]),ss,n("p",null,[s("在程序中从文件里读写数据需要使用 IO 流. Java 定义了相关的流类,在 "),n("a",as,[s("java.io"),p(a)]),s(" 包中,如果这个类是以 Stream 单词结尾就是字节流类, 如果是以 Reader 结尾就是字符输入流, 以 Writer 单词结尾就是字符输出流")]),ps])}const cs=e(An,[["render",ts],["__file","Java进阶.html.vue"]]);export{cs as default};

import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as p,c as s,a as t,b as e,e as r,f as o}from"./app-ee3e8713.js";const i="/assets/1f7ed249ff21dac3dba532147b915e52-6a960f95.png",c="/assets/e3d3d87bd56336a4fa52553f42a058f0-639086d6.png",u="/assets/b8de83bfce4db26fee0ed4b43426519d-db683837.png",d={},b=o(`<h1 id="java-高级" tabindex="-1"><a class="header-anchor" href="#java-高级" aria-hidden="true">#</a> Java 高级</h1><p><strong>作者：</strong> 胡鑫治</p><h1 id="异常体系" tabindex="-1"><a class="header-anchor" href="#异常体系" aria-hidden="true">#</a> 异常体系</h1><p>java.lang.Throwable 是，所有异常跟错误的超类</p><pre><code>    java.lang.Error 非常严重的错误，不能处理
</code></pre><p>java.lang.Exception 通过实现设计，可以避免</p><pre><code>    RuntimeException:运行期异常
</code></pre><p>自定义异常类</p><p>自定义异常类：</p><pre><code>java 提供的异常类，不够我们使用，需要自己定义一些异常类
</code></pre><p>格式：</p><pre><code>public class XXXExcepiton extends Exception l RuntimeException{

    添加一个空参数的构造方法

    添加一个带异常信息的构造方法

}
</code></pre><p>注意：</p><ol><li><p>自定义异常类一般都是以 Exception 结尾，说明该类是一个异常类</p></li><li><p>自定义异常类，必须的继承 Exception 或者 RuntimeException 继承 Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么 throws，要么 try...catch 继承 RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</p></li></ol><p>public class RegisterException extends Exception{<br>  //添加一个空参数的构造方法<br> public Registerexception(){<br>      super（）;<br>    }<br>  /<em>添加一个带异常信息的构造方法查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息</em>/<br> public RegisterException(String message){<br>    super（message）<br>    ;<br>  }<br>}</p><h1 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程" aria-hidden="true">#</a> 多线程</h1><p>并发与并行</p><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。</p><p>进程概念</p><ul><li>进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</li></ul><p>线程调度</p><ul><li>分时调度</li></ul><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p><ul><li>抢占式调度</li></ul><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java 使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p>Thread-创建多线程的方法</p><ol><li>继承 Thread 类类</li></ol><p><code>//1)定义继承 Thread</code></p><p><br>public class SubThread extends Thread {<br>    //2)重写 run()方法，run()方法体中的代码就是子线程要执行的代码<br>    @Override<br>    public void run() {<br>        for (int i = 1; i &lt; 101; i++) {<br>            System.out.println(&quot;sub thread : &quot; + i);<br>        }<br>    }<br>}</p><ol><li>实现 Runnable 接口</li></ol><p>//1)定义 Runnable<br>public class Prime implements Runnable {<br>  //2）重写 run（）方法，run 方法体就是用户线程执行的代码@Overridepublic void run() {//在子线程，打印 100 行字符串 for (int i = 1; i &lt; 101; i++) {System.out.println(&quot;sub thread : &quot; + i);}}}<br></p><ol><li>匿名内部类</li></ol><p>Thread t1 = new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                for (int i = 0; i &lt; 100; i++) {<br>                    System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + i);<br>                }<br>            }<br>        }, &quot;t1&quot;);<br>        //通过构造方法指定线程名称<br>        t1.start();</p><h1 id="网络编程" tabindex="-1"><a class="header-anchor" href="#网络编程" aria-hidden="true">#</a> 网络编程</h1><p>网络协议</p><ul><li>UDP 用户数据报协议（UDP，User Datagram Protocol）服务器不确认收到，不可靠</li></ul><p>优点是延迟低</p><ul><li>TCP 传输控制协议（Transmission Control Protocol，）是 TCP 通信：面向连接的通信，客户端和服务器端必须的经过 3 次握手，建立逻辑连接，才能通信（安全）</li></ul><p>命令行查看</p><p><code>ipconfig</code></p><p><code>ping</code></p><p>端口号</p><p>逻辑端口，无法直接看到</p><p>由两个字节组成，取值范围在 0-65535 之间</p><p>1024 之前的端口号不能使用，被系统分配给已知的网络软件</p><p>网络软件的端口号不能重复</p><p>常用的端口号</p>`,48),_={href:"http://www.baidu.com:80",target:"_blank",rel:"noopener noreferrer"},h={href:"http://www.baidu.com:70",target:"_blank",rel:"noopener noreferrer"},m=t("li",null,[t("p",null,"数据库 mysql：3306 oracle：1521")],-1),g=t("li",null,[t("p",null,"Tomcat 服务器：8080")],-1),f=o(`<p>TCP 通信</p><p>通信的步骤</p><p>服务器端先启动</p><p>服务器端不会主动的请求客户端</p><p>必须使用客户端请求服务器端</p><p>客户端和服务端就会建立一个逻辑连接</p><p>而这个连接中包含一个对象</p><p>这个对象就是 I0 对象</p><p>客户端和服务器端就可以使用</p><p>IO 对象进行通信</p><p>通信的数据不仅仅是字符</p><p>所以 IO 对象是字节流对象</p><p>服务器端必须明确两件事情：</p><ol><li><p>多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互在服务器端有一个方法，叫 accept 客户端获取到请求的客户端对象</p></li><li><p>多个客户端同时和服务器进行交互，就需要使用多个 IO 流对象</p><p>服务器是没有 10 流的，服务器可以获取到请求的客户端对象 Socket 使用每个客户端 Socket 中提供的 IO 流和客户端进行交互</p><pre><code>服务器使用客户端的字节输入流读取客户端发送的数据

服务器使用客户端的字节输出流给客户端回写数据
</code></pre><p>简单记：服务器使用客户端的流和客户端交互</p></li></ol><p>java 实现 TCPClient 和 TCPServer</p><p>文件上传案例的客户端</p><figure><img src="`+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端代码</p>',18),k=t("br",null,null,-1),x={href:"//1.xn--4gqvd70l20mpmaw2m5vgov1dp26a",target:"_blank",rel:"noopener noreferrer"},S=t("br",null,null,-1),v=t("br",null,null,-1),w={href:"//2.xn--2rqz13g",target:"_blank",rel:"noopener noreferrer"},q=t("br",null,null,-1),T=t("br",null,null,-1),y={href:"//3.xn--2rq53dpxnfus66i3tonxa20qf26a",target:"_blank",rel:"noopener noreferrer"},I=t("br",null,null,-1),C=t("br",null,null,-1),E={href:"//4.xn--2rqz13g",target:"_blank",rel:"noopener noreferrer"},O=t("br",null,null,-1),P=t("br",null,null,-1),z={href:"//5.xn--2rq19bh0qfus66i3tonxa20qf26a",target:"_blank",rel:"noopener noreferrer"},j=t("br",null,null,-1),L=t("br",null,null,-1),R=t("br",null,null,-1),U=t("br",null,null,-1),J={href:"//6.xn--4bv80syxzk7d",target:"_blank",rel:"noopener noreferrer"},N=t("br",null,null,-1),B=t("br",null,null,-1),A=t("br",null,null,-1),D=t("p",null,"服务端代码",-1),V=t("br",null,null,-1),W={href:"//1.xn--5brqmv0hytlkpk",target:"_blank",rel:"noopener noreferrer"},H=t("br",null,null,-1),X=t("br",null,null,-1),G={href:"//2.xn--2rqz13g",target:"_blank",rel:"noopener noreferrer"},K=t("br",null,null,-1),M=t("br",null,null,-1),F={href:"//3.xn--2rqz13g",target:"_blank",rel:"noopener noreferrer"},Q=t("br",null,null,-1),Y=t("br",null,null,-1),Z={href:"//4.xn--2rq19bh0qfus66i3tonxa20qf26a",target:"_blank",rel:"noopener noreferrer"},$=t("br",null,null,-1),ee=t("br",null,null,-1),te=t("p",null,[t("em",null,"out")],-1),ne=t("br",null,null,-1),re={href:"//5.xn--2rqz13g",target:"_blank",rel:"noopener noreferrer"},oe=t("br",null,null,-1),le=t("br",null,null,-1),ae={href:"//6.xn--2rq53dpxnfus66i3tonxa20qf26a",target:"_blank",rel:"noopener noreferrer"},pe=t("br",null,null,-1),se=t("br",null,null,-1),ie={href:"//7.xn--4bv80syxzk7d",target:"_blank",rel:"noopener noreferrer"},ce=t("br",null,null,-1),ue=t("p",null,"模拟 B/S 服务器",-1),de=t("p",null,"Java 开启 TCPServer，socket 开始监听，端口号：8080",-1),be=t("p",null,"输入网址：",-1),_e={href:"http://127.0.0.1:8080/itcast/net/web/18160217.html",target:"_blank",rel:"noopener noreferrer"},he=o('<p>TCPServer 读取客户端的请求信息</p><p>GET /itcast/net/web/18160217.html HTTP/1.1<br>Host: 127.0.0.1:8080<br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36<br>Sec-Fetch-Dest: document<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,ja;q=0.6</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="函数式接口" tabindex="-1"><a class="header-anchor" href="#函数式接口" aria-hidden="true">#</a> 函数式接口</h1><p>函数式接口在 Java 中是指：</p><p><strong>有且仅有一个抽象方法的接口</strong></p><p>函数式接口，即适用于函数式编程场景的接口。而 Java 中的函数式编程体现就是 Lambda，所以函数式接口就是可以适用于 Lambda 使用的接口。只有确保接口中有且仅有一个抽象方法，Java 中的 Lambda 才能顺利地进行推导。</p><p>Lambda 表示式</p><p>函数式接口的语法糖，需要用注解</p><p>@functionalInterface</p><p>标注，在方法中作为接口类型的参数，参数写在括号里，{}里重写接口的抽象方法</p><p>//调用 show 方法，方法的参数是一个函数式接口，所以我们可以 Lambda 表达式<br></p><p><em>show</em></p><p>(()-&gt;{<br>  System.</p><p><em>out</em></p><p>.println(&quot;使用 lambda 表达式重写接口的抽象方法&quot;); });</p><p>与匿名内部类的区别</p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>匿名内部类会造成新的字节码文件，在 idea 中并不显示；而 Lambda 不会</p><p>Lambda 的特点：延迟加载</p><p>只有被调用才会被执行</p><p><em>showLog</em></p><p>(1,( )-&gt;{     //返回一个拼接好的字符串 <br>  return msg1+msg2+msg3;<br>});</p><p>那么 msg1，msg2 和 msg3 变量的作用范围在哪里</p><p>作为参数和返回值，作为一个接口对象</p><p>常用的函数式接口</p><p>Supplier</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span>Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>接口仅包含一个无参的方法：<span class="token class-name">T</span> get（）。用来获取一个泛型参数指定类型的对象数据。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><em>Consumer</em></p><p><em>Consumer 接口中包含抽象方法 void accept（T t），意为消费一个指定泛型的数据。</em></p>`,30);function me(ge,fe){const n=a("ExternalLinkIcon");return p(),s("div",null,[b,t("ol",null,[t("li",null,[t("p",null,[e("80 端口网络端口 "),t("a",_,[e("www.baidu.com:80"),r(n)]),e(" 正确的网址 "),t("a",h,[e("www.baidu.com:70"),r(n)]),e(" 错误的网址打不开")])]),m,g]),f,t("p",null,[e("public class TCPClient { public static void main(String[] args) throws IOException { "),k,e("  "),t("a",x,[e("//1.创建一个客户端对象"),r(n)]),e(" Socket，构造方法绑定服务器的 IP 地址和端口号        "),S,e('  Socket socket=new Socket("127.0.0.1",8888);        '),v,e("  "),t("a",w,[e("//2.使用"),r(n)]),e(" Socket 对象中的方法 getOutputStream()获取网络字节输出流 Output stream 对象        "),q,e("  OutputStream os =socket.getOutputStream();        "),T,e("  "),t("a",y,[e("//3.使用网络字节输出流"),r(n)]),e(" Output Stream 对象中的方法 write，给服务器发送数据        "),I,e('  os.write("你好服务器".getBytes());        '),C,e("  "),t("a",E,[e("//4.使用"),r(n)]),e(" Socket 对象中的方法 get Inputstream（）获取网络字节输入流 InputStream 对象        "),O,e("  InputStream is=socket.getInputStream();        "),P,e("  "),t("a",z,[e("//5.使用网络字节输入流"),r(n)]),e(" InputStream 对象中的方法 read，读取服务器回写的数据        "),j,e("  byte[] bytes=new byte[1024];//一次性读 1024 个字节，返回读取字符个数       "),L,e("  int len=is.read(bytes);"),R,e("  System.out.println(new String(bytes,0,len));        "),U,e("  "),t("a",J,[e("//6.释放资源"),r(n)]),e("（Socket）       "),N,e("  socket.close();    "),B,e("}"),A,e("}")]),D,t("p",null,[e("public class TCPServer { public static void main(String[] args) throws IOException { "),V,e("  "),t("a",W,[e("//1.创建服务器"),r(n)]),e(" Serversocket 对象和系统要指定的端口号 "),H,e("  ServerSocket server =new ServerSocket(8888); "),X,e("  "),t("a",G,[e("//2.使用"),r(n)]),e(" ServerSocket 对象中的方法 accept，获取到请求的客户端对象 Socket"),K,e("  Socket socket =server.accept(); "),M,e("  "),t("a",F,[e("//3.使用"),r(n)]),e(" Socket 对象中的方法 get Inputstream（）获取网络字节输入流 Input Stream 对象 "),Q,e("  InputStream is= socket.getInputStream(); "),Y,e("  "),t("a",Z,[e("//4.使用网络字节输入流"),r(n)]),e(" Inputstream 对象中的方法 read，读取客户端发送的数据 "),$,e("  byte[] bytes=new byte[1024];//一次性读 1024 个字节，返回读取字符个数"),ee,e("  int len=is.read(bytes); System.")]),te,t("p",null,[e(".println(new String(bytes,0,len)); "),ne,e("  "),t("a",re,[e("//5.使用"),r(n)]),e(" Socket 对象中的方法 getoutputstream（）获取网络字节输出流 Output stream 对象 "),oe,e("  OutputStream os=socket.getOutputStream(); "),le,e("  "),t("a",ae,[e("//6.使用网络字节输出流"),r(n)]),e(" Output Stream 对象中的方法 write，给客户端回写数据 "),pe,e('  os.write("收到谢谢".getBytes());'),se,e("  "),t("a",ie,[e("//7.释放资源"),r(n)]),e("（Socket，ServerSocket） "),ce,e("  socket.close(); server.close(); }}")]),ue,de,be,t("p",null,[t("a",_e,[e("http://127.0.0.1:8080/itcast/net/web/18160217.html"),r(n)])]),he])}const Se=l(d,[["render",me],["__file","Java高级.html.vue"]]);export{Se as default};

import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as o,f as a}from"./app-ad0845b4.js";const c={},i=a('<p>箭头函数是传统函数表达式的简写方式，它简化了函数的编写，也带来了一些限制导致在一些场景下它无法使用。</p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点：</h3><ol><li>箭头函数没有自己的 <code>this</code></li><li>箭头函数中没有 <code>arguments</code><ol><li><code>arguments</code> 用来保存函数的实参。乍一看，结果是个数组，但并不是真正的数组，所以说 arguments 是一个<mark>类数组的对象</mark>（想了解真正数组与类数组对象的区别可以一直翻到最后）。将函数的 arguments 对象泄露出去了，最终的结果就是 V8 引擎将会跳过优化，导致相当大的性能损失。</li><li><code>(...args)</code> 代替，获取参数数组</li></ol></li><li>不能作为构造函数调用 <ol><li>不能 <code>new</code>，没有 <code>constructor</code></li><li>区分 普通函数和 构造函数</li></ol></li><li>无法通过 <code>call</code>、<code>apply</code>、<code>bind</code> 指定函数的 <code>this</code></li></ol><h2 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法" aria-hidden="true">#</a> 基本语法</h2><ul><li>只有一个参数的函数<br><code>参数 =&gt; 返回值</code></li><li>如果没有参数，或多个参数，参数需要使用()括起来<br><code>() =&gt; 返回值</code><br><code>(a, b, c) =&gt; 返回值</code></li><li>箭头后边的值就是函数的返回值 <ul><li>返回值必须是一个表达式（有值的语句）</li><li>如果返回值是对象，必须加 <code>()</code></li></ul></li><li>如果需要在箭头函数中定义逻辑，可以直接在箭头后跟一个代码块，<br> 代码块中语法和普通函数没有区别</li></ul><h2 id="arguments" tabindex="-1"><a class="header-anchor" href="#arguments" aria-hidden="true">#</a> arguments</h2><p>那就很好奇了，我们每次使用 arguments 时通常第一步都会将其转换为数组，同时 arguments 使用不当还容易导致性能损失，那么为什么不将 arguments 直接设计成数组对象呢？</p><p>这需要从这门语言的一开始说起。arguments 在语言的早期就引入了，当时的 Array 对象具有 4 个方法： toString、 join、 reverse 和 sort。arguments 继承于 Object 的很大原因是不需要这四个方法。而现在，Array 添加了很多强大的方法，比如 forEach、map、filter 等等。那为什么现在不在新的版本里让 arguments 重新继承自 Array 呢？其实 ES5 的草案中就包含这一点，但为了向前兼容，最终还是被委员会否决了。</p>',8),l=[i];function t(d,n){return r(),o("div",null,l)}const u=e(c,[["render",t],["__file","04-箭头函数.html.vue"]]);export{u as default};

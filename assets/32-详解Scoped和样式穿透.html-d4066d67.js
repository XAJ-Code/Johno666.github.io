import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as d,a as i,b as e,e as c,w as p,f as n}from"./app-ad0845b4.js";const r="/assets/image-2023-01-07_22-19-13-022-32-详解Scoped和样式穿透-65c0e92e.png",l="/assets/image-2023-01-07_22-19-55-026-32-详解Scoped和样式穿透-4e83d782.png",_="/assets/image-2023-01-07_22-20-10-526-32-详解Scoped和样式穿透-95671dad.png",h="/assets/image-2023-01-08_16-21-42-109-32-详解Scoped和样式穿透-cf3d131b.png",g="/assets/image-2023-01-08_16-23-47-021-32-详解Scoped和样式穿透-a3b89ea0.png",m={},u=n('<p>就需要用到样式穿透</p><h1 id="scoped-的原理" tabindex="-1"><a class="header-anchor" href="#scoped-的原理" aria-hidden="true">#</a> scoped 的原理</h1><p>vue 中的 scoped 通过在 DOM 结构以及 css 样式上加唯一不重复的标记:data-v-hash 的方式，以保证唯一（而这个工作是由过 PostCSS 转译实现的），达到样式私有化模块化的目的。</p><p>总结一下 scoped 三条渲染规则：</p><ul><li>给 HTML 的 DOM 节点加一个不重复 data 属性(形如：data-v-123)来表示他的唯一性</li><li>在每句 css 选择器的末尾（编译后的生成的 css 语句）加一个当前组件<code>.ipt</code>的 data 属性选择器（如<code>.ipt[data-v-123]</code>）来私有化样式</li><li>如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性</li></ul><p>PostCSS 会给一个组件中的所有 dom 添加了一个独一无二的动态属性 data-v-xxxx，然后，给 CSS 选择器额外添加一个对应的属性选择器来选择该组件中 dom，这种做法使得样式只作用于含有该属性的 dom——组件内部 dom, 从而达到了&#39;样式模块化&#39;的效果.</p><p>案例修改 Element ui Input 样式</p><p>发现没有生效<br><img src="'+r+'" alt="" loading="lazy"></p><p>如果不写 Scoped 就没问题</p><p>原因就是 Scoped 搞的鬼 他在进行 PostCss 转化的时候把元素选择器默认放在了最后</p><h1 id="样式穿透" tabindex="-1"><a class="header-anchor" href="#样式穿透" aria-hidden="true">#</a> 样式穿透</h1><h2 id="deep" tabindex="-1"><a class="header-anchor" href="#deep" aria-hidden="true">#</a> :deep()</h2><p>^e3f2d4</p><p>Vue3 提供了样式穿透 <code>:deep()</code> ，把类名放到括号里面，他的作用就是用来改变 属性选择器的位置(Vu2 <code>/deep/</code>)<br><img src="'+l+'" alt="" loading="lazy"></p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>相当于给 class 加了唯一 id</p><h2 id="源码解析" tabindex="-1"><a class="header-anchor" href="#源码解析" aria-hidden="true">#</a> 源码解析</h2><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>检测到 scoped ，添加 <code>postCss</code> 插件</p><h3 id="postcss-插件" tabindex="-1"><a class="header-anchor" href="#postcss-插件" aria-hidden="true">#</a> postCss 插件</h3><p>PostCSS 接收一个 CSS 文件并提供了一个 API 来分析、修改它的规则(通过把 CSS 规则转换成一个抽象语法树的方式)<br> 跟 babel 类似的 babel 是做 js 的， AST postCss 是做 Css 的</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',22);function f(S,b){const a=t("RouterLink");return o(),d("div",null,[i("p",null,[e("主要是用于修改很多 vue 常用的组件库（ "),c(a,{to:"/code/vue/vue3/31-%E4%BA%86%E8%A7%A3UI%E5%BA%93ElementUI%EF%BC%8CAntDesigin%E7%AD%89.html"},{default:p(()=>[e("了解 UI 库 ElementUI，AntDesigin 等")]),_:1}),e(" ），虽然配好了样式但是还是需要更改其他的样式")]),u])}const v=s(m,[["render",f],["__file","32-详解Scoped和样式穿透.html.vue"]]);export{v as default};
